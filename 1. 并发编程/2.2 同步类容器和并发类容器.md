## 2.2.1 实现自定义同步容器MyQueue

案例 【com.herolei._2_2.MyQueue】

```java
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * BlockQueue: 该队列支持阻塞机制，阻塞的放入和得到数据
 * put(Object o): BlockQueue无空间则调用此方法的线程被阻塞，直到BlockQueue有空间才被激活
 * take(): BlockQueue为空则调用此方法的线程被阻塞，直到BlockQueue有数据才被激活
 */
public class MyQueue {

	private final LinkedList<Object> list = new LinkedList<Object>();

	//元素个数计数器
	private final AtomicInteger count = new AtomicInteger(0);
	
	private final int maxSize;
	private final int minSize = 0;

	//锁
	private final Object lock = new Object();
	
	public MyQueue(int maxSize){
		this.maxSize = maxSize;
	}

	public void put (Object obj) {
		synchronized(lock){
			//1. 没有空间阻塞线程
			while(count.get() == maxSize){
				try {
					lock.wait();//阻塞
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			//2. BlockQueue有空间则添加数据且计数器自加
			list.add(obj);
			count.getAndIncrement();
			System.out.println(" 元素 " + obj + " 被添加 ");
			//3. BlockQueue有数据激活take()线程
			lock.notify();
		}
	}
	
	public Object take(){
		Object temp = null;
		//1. BlockQueue无数据阻塞线程
		synchronized (lock) {
			while(count.get() == minSize){
				try {
					lock.wait();//阻塞
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			//2. BlockQueue有数据并取出数据且计数器自减
			count.getAndDecrement();
			temp = list.removeFirst();
			System.out.println(" 元素 " + temp + " 被消费 ");
			//3. BlockQueue有数据激活put()线程
			lock.notify();
		}
		return temp;
	}
}
```

## 2.2.2 ThreadLocal

> ThreadLocal 是线程局部变量，是一种多线程间并发访问变量的无锁解决方案。

**ThreadLocal 和 synchronized 比较？**

1. 与 synchronized 等加锁的方式不同，ThreadLocal 完全不提供锁，而使用以空间换时间的手段，为每个线程提供变量的独立副本，以保障线程安全。

2. 从性能上说，ThreadLocal 不具有绝对的优势，在并发不是很高的时候，加锁的性能会更好，但作为一套无锁的解决方案，在高并发量或者竞争激烈的场景，使用 ThreadLocal 可以在一定程度上减少锁竞争。

案例 【com.herolei._2_2.ConnThreadLocal】

```java
package com.herolei._2_2;

public class ConnThreadLocal {

	public static ThreadLocal<String> th = new ThreadLocal<String>();
	
	public void setTh(String value){
		th.set(value);
	}
	public void getTh(){
		System.out.println(Thread.currentThread().getName() + ":" + this.th.get());
	}
	
	public static void main(String[] args) throws InterruptedException {
		
		final ConnThreadLocal ct = new ConnThreadLocal();
		Thread t1 = new Thread(new Runnable() {
			public void run() {
				ct.setTh("张三");
				ct.getTh();
			}
		}, "t1");
		
		Thread t2 = new Thread(new Runnable() {
			public void run() {
				try {
					Thread.sleep(1000);
					ct.setTh("李四");
					ct.getTh();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}, "t2");
		
		t1.start(); //t1:张三
		t2.start(); //t2:李四
	}
}
```

## 2.2.3 单例模式

* static inner class: 静态内部类模式实现单例

```java
public class InnerSingleton {
	
	private static class Singletion {
		private static Singletion single = new Singletion();
	}
	
	public static Singletion getInstance(){
		return Singletion.single;
	}
}
```
* dubble check instance: 

```java
public class DubbleSingleton {

	private static DubbleSingleton ds;
	
	public static DubbleSingleton getDs(){
        if(ds == null){
            try {
                //模拟初始化对象的准备时间...
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (DubbleSingleton.class) {
                if(ds == null){
                    ds = new DubbleSingleton();
                }
            }
        }
        return ds;
    }
}
```

## 2.2.4 同步类容器和并发类容器

### 同步类容器

如 Vector、HashTable 等容器的同步功能都是由 `Collections.synchronizedMap` 等工厂方法去创建实现的，底层使用 synchronized 关键字，每次只有一个线程访问容器。这明显不满足高并发的需求。

```java
//HashMap不是线程安全容器，加工后成功线程安全
Map<String, String> map = Collections.synchronizedMap(new HashMap<String, String>());
```

### 并发类容器

并发类容器 | 说明
--- | ---
ConcurrentHashMap | 替代HashTable
ConcurrentSkipListMap | 排序
CopyOnWriteArrayList | 替代Vector
ConcurrentLinkedQueue | 高性能队列
LinkedBlockingQueue | 阻塞形式队列