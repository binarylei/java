# Future模式

> Future模式的核心在于：去除了主函数的等待时间，并使得原本需要等待的时间段可以用于处理其他业务逻辑（根据《Java程序性能优化》）。

## 3.1.1 Future模式核心思想

如下的请求调用过程时序图。当call请求发出时，需要很长的时间才能返回。左边的图需要一直等待，等返回数据后才能继续其他操作；而右边的 Future模式的图中客户端则无需等到可以做其他的事情。服务器段接收到请求后立即返回结果给客户端，这个结果并不是真实的结果（是虚拟的结果），也就 是先获得一个假数据，然后执行其他操作。

![Future模式核心思想](http://www.2cto.com/uploadfile/Collfiles/20141113/20141113091348310.png)

## 3.1.2 Future模式Java实现

#### FutureClient的实现

Client主要完成的功能包括：1. 返回一个FutureData；2.开启一个线程用于构造RealData。

```java
public class FutureClient {
    public FutureData request(final String queryStr) {
        final FutureData future = new FutureData();
        new Thread(new Runnable() {
            @Override
            public void run() {
                future.request(queryStr);
            }
        }).start();
        return future;
    }
}
```

#### Data的实现

无论是FutureData还是RealData都实现该接口。

```java
public interface Data {
    String getRequest();
}
```
#### FutureData的实现

FutureData是Future模式的关键，它实际上是真实数据RealData的代理，封装了获取RealData的等待过程。

```java
public class FutureData implements Data {

    private boolean isReady = false;
    private RealData realData;

    public FutureData() {
    }

    public synchronized void setRealData(RealData realData) {
        if (isReady) {
            return;
        }
        this.isReady = true;
        this.realData = realData;
        this.notify();
    }

    public void request(String queryStr) {
        RealData realData = new RealData(queryStr);
        this.setRealData(realData);
    }

    public synchronized String getRequest() {
        if (!isReady) {
            try {
                wait();
            } catch (InterruptedException e) {
                ;
            }
        }
        return this.realData.getRequest();
    }
}
```

#### RealData的实现

RealData是最终需要使用的数据，它的构造函数很慢。

```java
public class RealData implements Data {
    private String data;

    public RealData(String queryStr) {
        this.data = deal(queryStr);
    }

    public String deal(String queryStr) {
        try {
            Thread.sleep(1000 * 5);
        } catch (InterruptedException e) {
            ;
        }
        return "这是处理后的结果...";
    }

    public String getRequest() {
        return this.data;
    }
}
```

#### 测试运行

```java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
FutureClient client = new FutureClient();
FutureData future = client.request("请求参数");

System.out.println(format.format(new Date()) + "发出请求...");
Thread.sleep(1000 * 2);

System.out.println(future.getRequest());
System.out.println(format.format(new Date()) + "收到结果...");
```

## 3.1.3 Future模式的JDK内置实现

`java.util.concurrent` 已经内置了Future模式的实现。其中最为重要的是 FutureTask 类，它实现了Runnable接口，作为单独的线程运行。在其 run() 方法中，通过 Sync 内部类调用 Callable 接口，并维护 Callable 接口的返回对象。当使用 FutureTask.get() 方法时，将返回 Callable 接口的返回对象。

### FutureTask 深度解析

FutureTask 有两个很重要的属性，分别是 `state`  `runner` ，futureTask之所以可以支持cancel操作 就是因为这两个属性

其中 state为 枚举值：

* `NEW` 新建 0
* `COMPLETING` 执行中 1
* `NORMAL` 正常 2
* `EXCEPTIONAL` 异常 3
* `CANCELLED` 取消 4
* `INTERRUPTING` 中断中 5
* `INTERRUNPED` 被中断 6

state的状态变化可以有四种方式：

* `NEW->COMPLETING->NORMAL` 正常完成的流程
* `NEW->COMPLETING->EXCEPTIONAL` 出现异常的流程
* `NEW->CANCELED` 被取消
* `NEW->INTERRUNPING->INTERRRUNPTED` 被中断

我们研究下Task的状态变化也就是一个任务的生命周期:

**java源代码：**

首先看一下 FutureTask 构造方法:

```java
public FutureTask(Callable<V> callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}
```

Task生命周期的变化,主要取决于 run()方法先被调用还是cancel () 方法会被调用，这两个方法的执行顺序决定了Task的生命周期的四种走向。我们先分析run方法先被调用的情况

```java
public void run() {
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                     null, Thread.currentThread()))
        return;
    try {
        Callable<V> c = callable;
        // 如果要执行的任务不为空 并且状态 new 就执行
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
            	// 执行任务
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
            	// 有异常
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } finally {
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        // //不管是否执行成功了 都把runner设置成null 
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
```

Task执行后如果成功会调用 set() 方法,如果有异常会调用 setException() 方法。

我们先看下set方法 ：

```java
protected void set(V v) { // (1)
	// 如过state是 NEW 把state设置成 COMPLETING
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = v;
        // 将任务设置成NORMAL
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
        finishCompletion();
    }
}
```

1. 如果现在的状态是 NEW 就把状态设置成 COMPLETING 然后设置成 NORMAL。这个执行流程导致的状态变化就是

	NEW->COMPLETING->NORMAL 

	执行步骤是：首先执行 run() 并且Task正常完成而且在这其间没有调用 cancel() 

2. 上边是任务正常执行完成的状态变化，我们在看下有异常的情况。有异常的话会调用setException()方法:

```java
protected void setException(Throwable t) { // (1)  
    // 如过state是new 把state设置成 COMPLETING 
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {  
        outcome = t;  
         // 将任务设置成 EXCEPTIONAL   
        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state  
        finishCompletion();  
    }  
}
```

1. 如果现在的状态是 NEW 就把状态设置成 COMPLETING，然后设置成 EXCEPTIONAL。这个执行流程导致的状态变化就是
	
	NEW->COMPLETING->EXCEPTIONAL 

	执行步骤是：首先执行 run() 并且Task抛出异常而且在这其间没有调用cancel()。

2. 上文所分析的场景只是 run() 方法被调用了，而在run()方法执行的过程中没有调用cancel()

	现在我们分析下cancel()方法先被调用的情况

```java
public boolean cancel(boolean mayInterruptIfRunning) {  // (1) 
	/** 
	* 如果state不是 NEW 那么就退出方法，这时的任务任务坑是已经完成了，或是被取消了，或是被中断了 
	* 如果是state 是 NEW 就设置 state 为中断状态或是取消状态 
	*/  
    if (!(state == NEW &&  
          UNSAFE.compareAndSwapInt(this, stateOffset, NEW,  
              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))  
        return false;  
    try {    // in case call to interrupt throws exception  
        //如果是可中断，那么就调用系统中断方法 然后把状态设置成INTERRUPTED  
        if (mayInterruptIfRunning) {  
            try {  
                Thread t = runner;  
                if (t != null)  
                    t.interrupt();  
            } finally { // final state  
                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);  
            }  
        }  
    } finally {  
        finishCompletion();  
    }  
    return true;  
}  
```

1. 如果是cancel(false) 那么Task的状态变化就是 NEW -> CANCELLED

2. 如果是cancel(true)那么Task的状态化就是 NEW -> INTERRUPTING -> INTERRUPTED

至此Task的四种状态变化我们都看到了，不过这都是在两个方法都是单独执行的情况。

我们在分析下两个方法交叉执行的情况：

1. 如果Task已经执行然后再调用cancel() (run()->cancel())

	* 调用cancel(false)情况

		1. 如果Task已经在执行而callable.call()没有返回 或是 call()已经返回但是state状态还没有改变
		  那么任务调用cancel(false) 不会对任务的执行造成影响 只会影响task的状态 

		2. 如果callable.call()已经返回并且状态已经变成COMPLETING或是 COMPLED 那么对任务执行 和任务状态都没有影响

	* 调用cancel(true)

		1. 如果任务已经在执行而callable.call()没有返回 会把state设置成 INTERRUPTING然后调用执行线程的中断请求 然后把状态设置成INTERRUPTED,这里 如果
		    callable.call() 方法可以响应中断 可能对任务执行产生影响，如果方法不会响应中断不会对任务运行产生影响。影响任务的状态

		2. 如果任务已经在执行并且 call()已经返回但是state状态还没有改变  不会对任务的执行造成影响 只会影响任务的状态 。

2. 调用cancel()后再执行任务 (cancel() -> run())

	先调用cancel()无论是那种调用方式都会引起state状态的变化。在run()方法执行的时候发现state已经不是new了 就会放弃任务的执行

### Future之HelloWorld

```java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
//ExecutorService pool = Executors.newFixedThreadPool(1);
FutureTask<Integer> future = new FutureTask<Integer>(new Callable<Integer>() {
    @Override
    public Integer call() throws Exception {
        Thread.sleep(5 * 1000);
        return new Random().nextInt(100);
    }
});

System.out.println(format.format(new Date()) + "发出请求...");
new Thread(future).start();
//pool.submit(future);

try {
    Integer ret = future.get();
    System.out.println(format.format(new Date()) + "收到结果，ret = " + ret);
} catch (InterruptedException e) {
    e.printStackTrace();
} catch (ExecutionException e) {
    e.printStackTrace();
}
```

### Future之ExecutorService

使用Callable和Future，通过ExecutorService的submit方法执行Callable，并返回Future，代码如下：

```java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
ExecutorService pool = Executors.newSingleThreadExecutor();

System.out.println(format.format(new Date()) + "发出请求...");
Future<Integer> future = pool.submit(new Callable<Integer>() {
    @Override
    public Integer call() throws Exception {
        Thread.sleep(5 * 1000);
        return new Random().nextInt(100);
    }
});

try {
    Integer ret = future.get();
    System.out.println(format.format(new Date()) + "收到结果，ret = " + ret);
} catch (InterruptedException e) {
    e.printStackTrace();
} catch (ExecutionException e) {
    e.printStackTrace();
}
```

代码是不是简化了很多，ExecutorService 继承自 Executor，它的目的是为我们管理Thread对象，从而简化并发编程，Executor使我们无需显示的去管理线程的生命周期，是JDK 5之后启动任务的首选方式。 

### Future之多任务

执行多个带返回值的任务，并取得多个返回值，代码如下：

```java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
ExecutorService threadPool = Executors.newCachedThreadPool();
CompletionService<Integer> cs = new ExecutorCompletionService<Integer>(threadPool);

System.out.println(format.format(new Date()) + "发出请求...");
for(int i = 1; i < 5; i++) {
    final int taskID = i;
    cs.submit(new Callable<Integer>() {
        public Integer call() throws Exception {
            Thread.sleep(5 * 1000);
            return taskID;
        }
    });
}

// 可能做一些事情
for(int i = 1; i < 5; i++) {
    try {
        System.out.println(format.format(new Date()) + "：" + cs.take().get());
    } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (ExecutionException e) {
        e.printStackTrace();
    }
}
```