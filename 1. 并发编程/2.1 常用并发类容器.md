# 2.1 同步类容器和并发类容器

## 2.1.1 同步类容器

同步类容器是**线程安全**的，如 Vector、HashTable 等容器的同步功能都是由 `Collections.synchronizedMap` 等工厂方法去创建实现的，底层使用 synchronized 关键字，每次只有一个线程访问容器。这明显**不满足高并发的需求**。

**源代码：** 【java.util.Vector】 底层使用 `synchronized` 修辞，显然是线程安全的

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
```

**源代码：** 【java.util.HashMap】 底层没有用 `synchronized` 修辞

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

由于 `java.util.HashMap` 底层没有用 `synchronized` 修辞，显然不是线程安全的，为了实现线程安全可以用 `Collections.synchronizedMap` 装饰一下，实现线程安全。

```java
//HashMap不是线程安全容器，加工后成功线程安全
Map<String, String> map = Collections.synchronizedMap(new HashMap<String, String>());
```

## 2.1.2 并发类容器

并发类容器 | 说明
--- | ---
ConcurrentHashMap | 替代HashTable
ConcurrentSkipListMap | 排序
CopyOnWriteArrayList | 替代Vector
ConcurrentLinkedQueue | 高性能队列
LinkedBlockingQueue | 阻塞形式队列

## 2.1.3 ConcurrentMap容器

> ConcurrentHashMap 容器内部使用(Segment)来表示不同的部分，每个段其实就是一个小的 HashTable ，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。把一个整体分成了16个段(Segment)。也就是最高支持16个线程的并发修改操作。这也是在多线程场景时**减小锁的粒度从而降低锁竞争**一种方案。并且代码中大多共享变量使用 volatile 关键字声明，目的是第一时间获取修改的内容，性能非常好。

ConcurrentMap 接口下两个重要的实现:

* ConcurrentHashMap

* ConcurrentSkipListMap(排序)



## 2.1.4 Copy-On-Write容器

> CopyOnWrite 容器既写时复制的容器，**用于读多写少的场景**。往一个容器添加元素时，不直接往当前容器添加，而是先将当前容器 Copy ，复制一个新的容器，然后往新的容器添加元素，添加完成之后，再将原容器的引用指向新的容器，这样做的好处是可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器是一种读写分离的思想，读和写不同的容器。

**源代码：** 【java.util.concurrent.CopyOnWriteArrayList】

```java
//Copy-On-Write 容器是一种读写分离的思想
public class CopyOnWriteArrayList<E> {
    //Copy-On-Write 容器写操作时加锁，写操作结束后解锁
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();//加锁
        try {
            //1. 获取原容器
            Object[] elements = getArray();
            int len = elements.length;
            //2. 原容器 -> Copy -> 新容器
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            //3. 往新容器写入内容
            newElements[len] = e;
            //4. 指向新容器
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();//解锁
        }
    }

    //读操作没有加锁，可以支持并发操作
    @SuppressWarnings("unchecked")
    private E get(Object[] a, int index) {
        return (E) a[index];
    }

    public E get(int index) {
        return get(getArray(), index);
    }
}
```

Copy-On-Write 容器下两个重要的实现:

* CopyOnWriteArrayList

* CopyOnWriteArraySet

```java
//CopyOnWriteArrayList <======> List 使用方法与List集合相同
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>();
list.add("a");
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
```