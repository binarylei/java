# 2.1 同步类容器和并发类容器

## 2.1.1 同步类容器

同步类容器是**线程安全**的，如 Vector、HashTable 等容器的同步功能都是由 `Collections.synchronizedMap` 等工厂方法去创建实现的，底层使用 synchronized 关键字，每次只有一个线程访问容器。这明显**不满足高并发的需求**。

**源代码：** 【java.util.Vector】 底层使用 `synchronized` 修辞，显然是线程安全的

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
```

**源代码：** 【java.util.HashMap】 底层没有用 `synchronized` 修辞

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

由于 `java.util.HashMap` 底层没有用 `synchronized` 修辞，显然不是线程安全的，为了实现线程安全可以用 `Collections.synchronizedMap` 装饰一下，实现线程安全。

```java
//HashMap不是线程安全容器，加工后成功线程安全
Map<String, String> map = Collections.synchronizedMap(new HashMap<String, String>());
```

## 2.1.2 并发类容器

并发类容器 | 说明
--- | ---
ConcurrentHashMap | 替代HashTable
ConcurrentSkipListMap | 排序
CopyOnWriteArrayList | 替代Vector
ConcurrentLinkedQueue | 高性能队列，无阻塞
LinkedBlockingQueue | 阻塞形式队列，阻塞

## 2.1.3 ConcurrentMap容器

> ConcurrentHashMap 容器内部使用(Segment)来表示不同的部分，每个段其实就是一个小的 HashTable ，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。把一个整体分成了16个段(Segment)。也就是最高支持16个线程的并发修改操作。这也是在多线程场景时**减小锁的粒度从而降低锁竞争**一种方案。并且代码中大多共享变量使用 volatile 关键字声明，目的是第一时间获取修改的内容，性能非常好。

ConcurrentMap 接口下两个重要的实现:

* ConcurrentHashMap

* ConcurrentSkipListMap(排序)

## 2.1.4 Copy-On-Write容器

> CopyOnWrite 容器既写时复制的容器，**用于读多写少的场景**。往一个容器添加元素时，不直接往当前容器添加，而是先将当前容器 Copy ，复制一个新的容器，然后往新的容器添加元素，添加完成之后，再将原容器的引用指向新的容器，这样做的好处是可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器是一种读写分离的思想，读和写不同的容器。

## 2.1.4 Copy-On-Write容器

> CopyOnWrite 容器既写时复制的容器，**用于读多写少的场景**。往一个容器添加元素时，不直接往当前容器添加，而是先将当前容器 Copy ，复制一个新的容器，然后往新的容器添加元素，添加完成之后，再将原容器的引用指向新的容器，这样做的好处是可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器是一种读写分离的思想，读和写不同的容器。

**源代码：** 【java.util.concurrent.CopyOnWriteArrayList】

```java
//Copy-On-Write 容器是一种读写分离的思想
public class CopyOnWriteArrayList<E> {
    //Copy-On-Write 容器写操作时加锁，写操作结束后解锁
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();//加锁
        try {
            //1. 获取原容器
            Object[] elements = getArray();
            int len = elements.length;
            //2. 原容器 -> Copy -> 新容器
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            //3. 往新容器写入内容
            newElements[len] = e;
            //4. 指向新容器
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();//解锁
        }
    }

    //读操作没有加锁，可以支持并发操作
    @SuppressWarnings("unchecked")
    private E get(Object[] a, int index) {
        return (E) a[index];
    }

    public E get(int index) {
        return get(getArray(), index);
    }
}
```

Copy-On-Write 容器下两个重要的实现:

* CopyOnWriteArrayList

* CopyOnWriteArraySet

```java
<<<<<<< .mine
//CopyOnWriteArrayList <======> List 使用方法与List集合相同
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>();
list.add("a");
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
```

## 2.1.5 ConcurrentLinkedQueue无阻塞队列

> 适合高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能，通常 ConcurrentLinkedQueue 性能好于 LinkedBlockingQueue。它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则，且不允许 null 元素。

ConcurrentLinkedQueue 重要方法：

1. add()和offer()：添加元素(ConcurrentLinkedQueue 下两个方法无区别)。

2. poll()和peek()：取头元素节点，区别在于前者删除元素，后者不会。


## 2.1.6 LinkedBlockingQueue阻塞队列

### ArrayBlockingQueue

> 基于数组的阻塞队列实现，其内部维护了一个定长数组，以便缓存队列中的数据对象。**没有实现读写分离**，也就意味着生产和消费不能完全并行，需要定义长度，可以指定先进先出或者先进后出，也叫**有界队列**。

### LinkedBlockingQueue

> 基于链表的阻塞队列实现，其内部维护了一个数据缓冲队列(链表构成)，以便缓存队列中的数据对象。实现了读写分离(读和写两个锁)，从而实现生产和消费的完全并行，进而能够**高效的处理并发数据**，是一个**无界队列**。

### SynchronousQueue

> 一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并消费。

### PriorityBlockingQueue

> 基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定，即传入队列的对象必须实现Comparable接口)实现。其内部控制线程同步的锁采用的是公平锁，也是一个无界队列。

```java
import java.util.concurrent.PriorityBlockingQueue;

public class PriorityBlockingQueueTest {

    public static void main(String[] args) {
        PriorityBlockingQueue queue = new PriorityBlockingQueue();
        queue.add(new Task(1));
        queue.add(new Task(6));
        queue.add(new Task(5));

        while (true) {
            if (queue.size() == 0)
                break;
            try {
                System.out.println(queue.take()); // (1)
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        /*for (Iterator it = queue.iterator(); it.hasNext();) {
            Task task = (Task) it.next();  // (2) 
            System.out.println(task);
        }*/
    }
}

class Task implements Comparable {
    private int id;

    @Override
    public int compareTo(Object o) {
        Task task = (Task) o;
        return this.id > task.id ? 1 : (this.id < task.id ? -1 : 0);
    }

    public void setId(int id) {
        this.id = id;
    }
    public Task(int id) {
        this.id = id;
    }
    public String toString() {
        return "Task{" + "id=" + id + '}';
    }
}
```

1. `take/poll/peek` 时，queue 队列按优先级顺序取出元素，程序执行结果如下：Task{id=1}，Task{id=5}，Task{id=6}

2. 注意：`queue.iterator()` 时，queue 队列并**不是**按优先级顺序，结果如下：Task{id=1}，Task{id=6}，Task{id=5}

### DelayQueue

> 带有延迟时间的队列，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取元素(传入的元素必须实现Delayed接口)，也是一个无界队列。应用场景比如缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等。

```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;

/**
 * 延迟队列：模仿网吧上网场景
 */
public class DelayQueueTest extends Thread {

    DelayQueue queue =  new DelayQueue();
    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    public void shangji(String name, int money) {
        WangMing wm = new WangMing(name, System.currentTimeMillis() + money * 1000l);
        queue.add(wm);
        System.out.println(name + "开始上网，时间：" + format.format(new Date()) +
                "，预计下机时间为：" + format.format(new Date(wm.getEndTime())));
    }

    public void xiaji(WangMing wm) {
        System.out.println(wm.getName() + "下机，时间：" + format.format(new Date(wm.getEndTime())));
    }

    public void run() {
        while (true) {
            try {
                WangMing wm = (WangMing) queue.take();
                xiaji(wm);
            } catch (InterruptedException e) {
                ;
            }
        }
    }

    public static void main(String[] args) {
        DelayQueueTest wangba = new DelayQueueTest();
        wangba.start();

        wangba.shangji("A", 5);
        wangba.shangji("B", 2);
        wangba.shangji("C", 4);
    }
}

/**
 * 网民，必须实现 Delayed 接口
 */
class WangMing implements Delayed {
    private String name;
    private long endTime;
    private TimeUnit timeUnit = TimeUnit.SECONDS;

    @Override
    public long getDelay(TimeUnit unit) {
        return endTime - System.currentTimeMillis();
    }

    @Override
    public int compareTo(Delayed o) {
        WangMing wm = (WangMing) o;
        return this.getDelay(timeUnit) - wm.getDelay(timeUnit) > 0 ? 1 :
                (this.getDelay(timeUnit) - wm.getDelay(timeUnit) < 0 ? -1 : 0);
    }

    public WangMing(String name, long endTime) {
        this.name = name;
        this.endTime = endTime;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public long getEndTime() {
        return endTime;
    }

    public void setEndTime(long endTime) {
        this.endTime = endTime;
    }
}
```

程序执行结果：

```
A开始上网，时间：2017-12-07 09:37:52，预计下机时间为：2017-12-07 09:37:57
B开始上网，时间：2017-12-07 09:37:52，预计下机时间为：2017-12-07 09:37:54
C开始上网，时间：2017-12-07 09:37:52，预计下机时间为：2017-12-07 09:37:56
B下机，时间：2017-12-07 09:37:54
C下机，时间：2017-12-07 09:37:56
A下机，时间：2017-12-07 09:37:57
```