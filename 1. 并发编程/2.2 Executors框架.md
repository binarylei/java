# Executors框架

Java 通过 Executors 提供四种线程池，分别为：

* `newFixedThreadPool` 创建一个固定数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待。

	```java
	public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
    ```

* `newSingleThreadExecutor` 创建一个单线程的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

	```java
	public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
    ```

* `newCachedThreadPool` 创建一个可根据实际情况调整线程个数的线程池，不限制最大线程个数。当有任务提交时，用空闲线程执行任务，没有则创建一个线程，并且每个空闲线程会在60秒后自动回收。

	```java
	public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
	```

* `newScheduledThreadPool` 创建一个定长线程池，支持定时及周期性任务执行。

	```java
	public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
    ```

* 自定义线程池

	```java
	public ThreadPoolExecutor(
		int corePoolSize,		// 核心线程数，初始化的线程数
		int maximumPoolSize,	// 最大线程数
		long keepAliveTime,		// 空闲线程最大存活时间
		TimeUnit unit,			// 单位
		BlockingQueue<Runnable> workQueue,	// 任务队列
		ThreadFactory threadFactory,		// 
		RejectedExecutionHandler handler	// 拒绝任务时的操作(拒绝策略)
	) {}
	```

## 自定义线程池

自定义线程池有两个重要的参数：BlockingQueue 和 RejectedExecutionHandler

* `BlockingQueue` 任务队列：
 
 	1. 使用有界队列时，有新的任务需要执行时：a. 若线程池实际线程数小于 corePoolSize ，则优先创建线程；b. 若大于 corePoolSize 则会将任务加入队列；c. 若队列已满，则在总线程数不大于 maximumPoolSize 的前提下，创建新的线程；d. 若线程数大于 maximumPoolSize 则执行拒绝策略。

 	2. 使用无界队列时，与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新任务到来时，a. 若线程数小于 corePoolSize 时，则创建新的线程；b. 若等于 corePoolSize 则将任务加入队列中，但就不会继续增加线程，也就是说，使用有界队列时，线程池的最大线程数为 corePoolSize；c. 若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存为至。

* `RejectedExecutionHandler` JDK拒绝策略：

	1. `AbortPolicy` 该策略直接抛出异常，阻止系统工作

	2 `CallerRunsPolicy`  只要线程池未关闭，该策略直接在调用者线程中运行当前被丢弃的任务。显然这样不会真的丢弃任务，但是，调用者线程性能可能急剧下降。

	3. `DiscardOledestPolicy`  丢弃最老的一个请求任务，也就是丢弃一个即将被执行的任务，并尝试再次提交当前任务。

	4. `DiscardPolicy` 默默的丢弃无法处理的任务，不予任何处理。

	5. `RejectedExecutioHandler` 自定义拒绝策略，接口如下：

		```java
		public interfaceRejectedExecutionHandler{
		    voidrejectedExecution(Runnable r,ThreadPoolExecutor executor);
		}
		```

自定义线程池例子：

```java
public class CustomedThreadPoolTest implements Runnable {
    private int id;
    private SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    public CustomedThreadPoolTest(int id) {
        this.id = id;
    }
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            ;
        }
        System.out.println(format.format(new Date()) + " " + Thread.currentThread().getName() +
                "：任务-" + this.id);
    }
    
    public static void main(String[] args) throws InterruptedException {
        LinkedBlockingQueue queue = new LinkedBlockingQueue();  // (1)
        //ArrayBlockingQueue queue = new ArrayBlockingQueue(5); // (2)
        ThreadPoolExecutor customPool = new ThreadPoolExecutor(
                2,      // 核心线程
                5,  	// 最大线程，无界队列时无用
                5,		// 线程最大空闲时间
                TimeUnit.SECONDS,
                queue, 	// 任务缓存
                new RejectedExecutionHandler() { // (3)
                    @Override
                    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                        System.out.println("拒绝：任务-" + ((CustomedThreadPoolTest) r).getId());
                    }
                }
        );

        for (int i = 1; i <= 10; i++) {
            customPool.execute(new CustomedThreadPoolTest(i));
        }

        Thread.sleep(1000);
        System.out.println("剩余的任务数量为：" + queue.size());
        customPool.shutdown();
    }
}
```

1. 使用无界队列 LinkedBlockingQueue 时，

	* 第一步：创建 corePoolSize=2 个线程分别执行"任务-1"、"任务-2"；

	* 第二步：其余任务全部加入到 queue 队列中，若有空闲的线程则依次取出任务执行， **有界队列的最大线程数是 `corePoolSize` **

	```
	剩余的任务数量为：10
	2017-12-09 03:51:32 pool-1-thread-2：任务-2
	2017-12-09 03:51:32 pool-1-thread-1：任务-1
	2017-12-09 03:51:33 pool-1-thread-1：任务-4
	2017-12-09 03:51:33 pool-1-thread-2：任务-3
	2017-12-09 03:51:34 pool-1-thread-1：任务-5
	2017-12-09 03:51:34 pool-1-thread-2：任务-6
	2017-12-09 03:51:35 pool-1-thread-1：任务-7
	2017-12-09 03:51:35 pool-1-thread-2：任务-8
	2017-12-09 03:51:36 pool-1-thread-1：任务-9
	2017-12-09 03:51:36 pool-1-thread-2：任务-10
	2017-12-09 03:51:37 pool-1-thread-1：任务-11
	2017-12-09 03:51:37 pool-1-thread-2：任务-12
	```

2. 使用有界队列 ArrayBlockingQueue 时，

	* 第一步：先创建 corePoolSize=2 个线程执行"任务-1"-"任务-2"；

	* 第二步：将其余的任务全部加入到 queue 中，直到 queue 被装满(5个 任务3-任务7)；

	* 第三步：创建新的线程执行剩余的任务，直到达到 maximumPoolSize=5 ，即执行"任务8"-"任务10"；

	* 第四步：对其余的任务执行拒绝策略，"任务-11"-"任务-12"；

	* 第五步：从队列中依次取出线程执行。

	```
	拒绝：任务-11
	拒绝：任务-12
	剩余的任务数量为：5
	2017-12-09 03:46:32 pool-1-thread-2：任务-2
	2017-12-09 03:46:32 pool-1-thread-3：任务-8
	2017-12-09 03:46:32 pool-1-thread-4：任务-9
	2017-12-09 03:46:32 pool-1-thread-5：任务-10
	2017-12-09 03:46:32 pool-1-thread-1：任务-1
	2017-12-09 03:46:33 pool-1-thread-2：任务-3
	2017-12-09 03:46:33 pool-1-thread-3：任务-4
	2017-12-09 03:46:33 pool-1-thread-4：任务-5
	2017-12-09 03:46:33 pool-1-thread-5：任务-6
	2017-12-09 03:46:33 pool-1-thread-1：任务-7
	```

3. 自定义拒绝策略 `rejectedExecution`

	```java
	new RejectedExecutionHandler() { // (3)
        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        	// 记录日志，空闲再做处理
            System.out.println("拒绝：任务-" + ((CustomedThreadPoolTest) r).getId());
        }
    }
    ```