## 1.2.1 synchronized

### synchronized锁重入

> 关键字 synchronized 拥有锁重入的功能，也就是在使用 synchronized 时，当线程等到一个对象的锁后，再次请求此对象时可以再次得到该对象的锁。出现异常时释放锁。

### synchronized异常

### synchronized代码块

> 使用 synchronized 声明的方法在某些情况下是有弊端的，比如A线程调用同步的方法执行一个很长时间的任务，那么B线程就必须等待比较长的时间才能执行，这样的情况下可以使用 synchronized 代码块去优化代码执行时间，也就是通常所说的减小锁的粒度。

synchronized代码块案例 【com.herolei._1_2sync.ObjectLock】

synchronized对常量加锁的问题 【com.herolei._1_2sync.StringLock】

注意：锁对象发生改变问题，当使用一个对象进行加锁的操作，要注意对象本身发生改变的时候，那么持有的锁就不同。

## 1.2.2 volatile

> volatile关键字具备可见性，不具备原子性。主要作用是使变量在多个线程间可见。但不具备原子性(同步性)，可以算一个轻量级的 synchronized ，性能要比 synchronized 强很多，不会造成阻塞。

volatile可见性案例 【com.herolei._1_2sync.VolatileThread】

```java
package com.herolei._1_2sync;

public class VolatileThread extends Thread {

    //volatile修辞的变量，变量发生变化时会强制性从主线程栈中读取该变量
    private volatile boolean isRuning = true;

    public void setIsRuning(boolean isRuning) {
        this.isRuning = isRuning;
        System.out.println("变量isRuning设置成功");
    }

    public void run () {
        //主线程调制的变量isRuning生效，程序退出while语句
        while (isRuning) {
           // do ...
        }
    }

    public static void main(String[] args) throws InterruptedException {
        VolatileThread vt = new VolatileThread();
        vt.start();
        Thread.sleep(1000);
        //主线程调制的变量isRuning在线程vt中生效,，即实现了可见性
        vt.setIsRuning(false);
    }
}
```

volatile非原子性 【com.herolei._1_2sync.VolatileNotAtomic】

要想保证原子性，可以用 synchronized 修辞，或使用 AtomicInteger 类

```java
package com.herolei._1_2sync;

import java.util.concurrent.atomic.AtomicInteger;

public class VolatileNotAtomic extends Thread {

    private static volatile int count;
    //private static AtomicInteger count = new AtomicInteger(0);

    public static void addCount() {
        for (int i = 0; i < 1000; i++) {
            count++;
            //count.incrementAndGet();
        }
        System.out.println(count);
        //使用volatile关键字，最后的结果不是1000*10
        //要想保证原子性，可以使用AtomicInteger类，只保证最后的结果正确，中间可能有误
    }

    public void run () {
        addCount();
    }

    public static void main(String[] args) throws InterruptedException {
        VolatileNotAtomic[] vna = new VolatileNotAtomic[10];
        for (int i = 0; i < 10; i++) {
            vna[i] = new VolatileNotAtomic();
        }
        for (int i = 0; i < vna.length  ; i++) {
            vna[i].start();
        }
    }
}
```