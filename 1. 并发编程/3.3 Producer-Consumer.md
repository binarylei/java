# Producer-Consumer

## 3.2.1 Master-Worker模式核心思想

Master-Worker 系统由两个角色组成，Master和Worker，Master负责接收和分配任务，Worker负责处理子任务。任务处理过程中，Master还负责监督任务进展和Worker的健康状态；Master将接收Client提交的任务，并将任务的进展汇总反馈给Client。各角色关系如下图：

![Master-Worker角色关系](http://img.blog.csdn.net/20160930063201507)

## 3.2.2 Master-Worker模式Java实现

#### Producter的实现

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class Producter implements Runnable {

    private BlockingQueue<Data> data;
    //用于生成id
    private static AtomicInteger count = new AtomicInteger(0);

    public Producter(BlockingQueue<Data> data) {
        this.data = data;
    }

    public Producter() { }

    @Override
    //生产者生产数据
    public void run() {
        try {
            Thread.sleep(2000);
            int id = count.incrementAndGet();
            if (!this.data.offer(new Data(id, "data-" + id), 2, TimeUnit.SECONDS)) {
                System.out.printf("%s生产：data-%s失败\n", Thread.currentThread().getName(), id);
            } else {
                System.out.printf("%s生产：data-%s\n", Thread.currentThread().getName(), id);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
```

#### Consumer的实现

```java
import java.util.concurrent.BlockingQueue;

public class Consumer implements Runnable {

    private BlockingQueue<Data> data;

    public Consumer(BlockingQueue<Data> data) {
        this.data = data;
    }
    public Consumer() { }

    @Override
    //消费者消费数据
    public void run() {
        Data d = null;
        try {
            d = this.data.take();
            System.out.printf("%s消费：%s\n", Thread.currentThread().getName(), d.getName());

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

#### Data

```java
public class Data {
    private int id;
    private String name;

    public Data(int id, String name) {
        this.id = id;
        this.name = name;
    }
    public Data() { }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Data{" + "id=" + id + ", name='" + name + '\'' + '}';
    }
}
```

#### 测试

```java
LinkedBlockingQueue<Data> data = new LinkedBlockingQueue<Data>();

Producter p1 = new Producter(data);
Producter p2 = new Producter(data);
Producter p3 = new Producter(data);

Consumer c1 = new Consumer(data);
Consumer c2 = new Consumer(data);
Consumer c3 = new Consumer(data);

ExecutorService pool = Executors.newCachedThreadPool();
pool.execute(p1);
pool.execute(p2);
pool.execute(p3);
pool.execute(c1);
pool.execute(c2);
pool.execute(c3);
pool.shutdown();
```