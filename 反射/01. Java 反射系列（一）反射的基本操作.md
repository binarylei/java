# Java 反射系列（一）反射的基本操作

1. 反射的基本概念
2. 分析简单 Java 类与反射的联系
3. 利用反射解决Servlet代码过多的问题
4. 利用反射来解决工厂设计模式、代理设计模式的操作
5. 动态代理设计、CGLIB实现的动态代理设计模式
6. 使用Annotation编写注定操作

## 1. 反射的基本概念

如果在正常情况下，如果要使用一个类，则必须按照如下步骤操作：

1. 使用 import 导入类所在的包；
2. 明确的使用类名或接口名称定义对象；
3. 通过关键字new进行类对象实例化(构造方法：java.lang.reflect.Contructor)；
4. 产生对象可以使用"对象.属性"进行类中属性的调用(属性：java.lang.reflect.Field)；
5. 通过"对象.方法"调用类中方法(方法：java.lang.reflect.Method)。

而反射的过程呢？不需要有明确类型的对象，所有的对象使用Object表示：

1. 可以直接利用Object与反射机制的混合调用类中的方法。

## Class类

Class 类是整个反射操作源头，其泛型几乎不用，就用 `Class<?>`，而这个类的定义如下：

```java
public final class Class<T> implements java.io.Serializable,
    GenericDeclaration, Type, AnnotatedElement
```

### 获取class对象

但是如果想要使用 Class 类进行操作，那么就必须首先产生 Class 类的实例化对象，而有如下三种方式获取 Class 类的实例化对象：

* 方式1: Class clazz = Class.forName("全限定名")

* 方式2: Class clazz = 类名.class

* 方式3: Class clazz = 对象.getClass

如果是程序设计的人员，使用最多的方法一定是 forName() 方式，如果是使用人员，肯定会使用 "类.class" 方式，通过分析可以知道，工厂设计模式最好利用反射机制解决耦合问题。

### 利用反射实例化对象

Class 类如果使用了 forName() 方法后，就可以使用 Class 类定义的 newInstance() 方法默认调用类的无参构造方法进行操作：

    public T newInstance()

这个时候可以非常清楚的发现，在整个程序编写之中，即使完全不知道类的结构，即使不导入包，也可以进行类对象实例化操作。

### 操作构造方法

但是如果使用反射实例化类对象，必须要求类中存在有无参构造方法。因为 newInstance() 方法默认调用类的无参构造方法。这个时候就只能够取得类之中的构造方法，传递所需要的参数后才可以执行。

在 Class 类中定义了可以取得一个类之中构造方法的操作：

* 取得类中所有的构造方法：

    public Constructor<?>[] getConstructors()

* 取得类中指定参数的构造方法：

    public Constructor<T> getConstructor(Class<?>... parameterTypes)

所以如果现在要进行指定构造方法的调用，就必须将关注点放在 Constructor 类中实例化对象方法：

    public T newInstance(Object ... initargs)

正是因为如果是通过构造方法实例化对象规格不统一，所以在进行简单 Java 类操作的时候就明确给出了，必须有无参构造方法。

### 调用类中的方法

取得一个类的实例化对象之后，下面主要的任务就是要调用类中可以使用的操作方法，对于一个类之中可以

* 取得类或接口的公共成员方法：

    public Method[] getMethods()
    public Method getMethod(String name, Class<?>... parameterTypes)

* 取得类或接口的所有声明的方法，包括公共、保护、默认访问和私有方法，但不包括继承的方法：

    public Method[] getDeclaredMethods()
    public Method getDeclaredMethod(String name, Class<?>... parameterTypes)


```java
Class<\?> cls = Class.forName("java.lang.Object");
Method[] methods = cls.getMethods();
for (int i = 0; i < methods.length; i++) {
    System.out.println(methods[i]);
}
```

现在的程序是直接调用了 Method 类中的 toString() 方法实现的输出。如果自定义输出，则需要使用到 Method 类的如下方法：

* 取得方法修饰符：

    程序中找的不是pubilc、static等关键字，而是关键字所代表的数字，要转化为可以读懂的信息，则可以借助 Modifier 类完成，此类中可以直接

* 取得方法的返回参数类型：
* 取得方法的参数：
* 取得方法所抛出的异常：

```java
Class<?> cls = Class.forName("java.lang.Object");
Method[] methods = cls.getMethods();
for (int i = 0; i < methods.length; i++) {
    //System.out.println(methods[i]);
    //1 取得方法修饰符
    System.out.print(Modifier.toString(methods[i].getModifiers()) + " ");
    //2 取得方法的返回参数类型
    System.out.print(methods[i].getReturnType().getSimpleName() + " ");
    //3 取得方法的名称
    System.out.print(methods[i].getName());
    
    //4 取得方法的参数
    Class<?>[] params = methods[i].getParameterTypes();
    System.out.print("(");
    if (params.length > 0) {
        for (int j = 0; j < params.length; j++) {
            System.out.print(params[j].getSimpleName() + " arg-" + j);
            if (j < params.length -1) {
                System.out.print(", ");
            }
        }
    }
    System.out.print(")");

    //5 取得方法所抛出的异常
    Class<?>[] exps = methods[i].getExceptionTypes();
    if (exps.length > 0) {
        System.out.print(" throws ");
        for (int j = 0; j < exps.length; j++) {
            System.out.print(exps[j].getSimpleName());
            if (j < exps.length -1) {
                System.out.print(", ");
            }
        }
    }
    System.out.println();
}   
```

此类代码一般只会编写开发工具的时候出现，而所谓的随笔提示功能就是依据以上的代码方式实现的。而与我们开发者关联最紧密的一定是利用 Mothod 调用类中的方法，而且在 Mothod 类中有一个重要的方法：

    public Object invoke(Object obj, Object... args)

正因为如此，所以在开发中才强调用getter、setter必须按照严格的要求。

### 调用类中的属性(尽量不要去使用)

关于类中的属性也可以直接利用反射进行操作，而支持的方法的两类：

* 取得类的属性(包括继承)：

    public Field[] getFields()
    public Field getField(String name)

* 取得本类的属性(不包括继承的)：

    public Field[] getDeclaredFields()
    public Field getDeclaredField(String name)

在开发中，只需要灵活使用Class、Constructor、Method、Field就可以使用反射进行一系列操作的代码实现。










