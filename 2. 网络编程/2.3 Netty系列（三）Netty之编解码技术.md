# Netty系列（三）Netty之编解码技术

> 编解码技术是指 Java 序列化技术，序列化目的就两个，一是进行网络传输，二是对象持久化。

Java 本身的对象序列化后 Netty 传输硬伤太多，比如 Java 序列化没法跨语言、序列化后码流太大、序列化性能太低。

主流的编码框架：

1. JBoss 的 Marshalling

2. google 的 Protobuf

3. 基于 Protobuf 的 Kyro

4. MessagePack 框架

## 获得 JBoss Marshalling

> [JBoss Marshalling](http://jbossmarshalling.jboss.org/downloads) 是一个 java 对象序列化包，对 JDK 默认的序列化框架进行了优化，但又保持跟 java.io.Serializable 接口的兼容，同时增加了一些可调用的参数和附加特性。

1. 引入 jboss-marshalling

```xml
<dependency>
    <groupId>org.jboss.marshalling</groupId>
    <artifactId>jboss-marshalling</artifactId>
    <version>1.3.0.CR9</version>
</dependency>
<dependency>
    <groupId>org.jboss.marshalling</groupId>
    <artifactId>jboss-marshalling-serial</artifactId>
    <version>1.3.0.CR9</version>
</dependency>
```

## JBoss Marshalling 之 HelloWrold

编写基于 JBoss Marshalling 的编码和解码类 MarshallingCodeFactory 

```java
public class MarshallingCodeFactory {

    //创建 jboss-marshalling 解码源 MarshallingDecoder
    public static MarshallingDecoder buildMarshallingDecoder () {
        //1. 通过 Marshalling 工具类获取 Marshalling 实例对象，参数 serial 标识创建的是 java 序列化工厂对象
        final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");

        //2. 创建 MarshallingConfiguration 对象，配置了版本号为5
        final MarshallingConfiguration configuration = new MarshallingConfiguration();
        configuration.setVersion(5);

        //3. 根据 marshallerFactory 和 configuration 创建 provider
        UnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration);

        //4. 构建 Netty 的 MarshallingDecoder 对象，两个参数分别为 provider 和 单个消息序列化后的最大长度
        return new MarshallingDecoder(provider, 1024 * 1024 *1);
    }

    //创建 jboss-marshalling 编码源 MarshallingEncoder
    public static MarshallingEncoder buildMarshallingEncoder () {
        //1. 通过 Marshalling 工具类获取 Marshalling 实例对象，参数 serial 标识创建的是 java 序列化工厂对象
        final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");

        //2. 创建 MarshallingConfiguration 对象，配置了版本号为5
        final MarshallingConfiguration configuration = new MarshallingConfiguration();
        configuration.setVersion(5);

        //3. 根据 marshallerFactory 和 configuration 创建 provider
        MarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration);

        //4. 构建 Netty 的 MarshallingEncoder 对象，参数为 provider
        return new MarshallingEncoder(provider);
    }
}
```

3. 传输的数据都要实现 Serializable 接口

```java
//请求数据
public class Request implements Serializable{
    private String id ;
    private String name ;
    private String requestMessage ;
}

//请求数据
public class Request implements Serializable{
    private String id;
    private String name;
    private String responseMessage;
}
```

4. Client 和 Server 都要添加 JBoss Marshalling 压缩和解压缩

```java
.handler(new LoggingHandler(LogLevel.INFO))
.handler(new ChannelInitializer<SocketChannel>() {
    @Override
    protected void initChannel(SocketChannel sc) throws Exception {
        sc.pipeline().addLast(MarshallingCodeFactory.buildMarshallingDecoder());
        sc.pipeline().addLast(MarshallingCodeFactory.buildMarshallingEncoder());
        //超时handler（当服务器端与客户端在指定时间以上没有任何进行通信，则会关闭响应的通道，主要为减小服务端资源占用）
        sc.pipeline().addLast(new ReadTimeoutHandler(5));
        sc.pipeline().addLast(new ClientHandler());
    }
});
```

5. Client 发送数据

```java
public class Client {
    public static void main(String[] args) {
        //... f = b.connect("127.0.0.1", 8765).sync();
        for(int i = 1; i <= 3; i++ ){
            Request request = new Request("" + i, "name-" + i, "requestMessage-" + i);
            f.channel().writeAndFlush(request);
            TimeUnit.SECONDS.sleep(1);
        }
    }
}
```


6. ServerHandler 接收数据处理

```java
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    System.out.println((Request)msg);
}
```

7. Server 接收的数据如下：

```
Request{id='1', name='name-1', requestMessage='requestMessage-1'}
Request{id='2', name='name-2', requestMessage='requestMessage-2'}
Request{id='3', name='name-3', requestMessage='requestMessage-3'}
```

### 2.3.2 文件传输

网络传输文件时，都要先进行数据压缩，具体步骤如下：

1. 添加 GzipUtils 类，用于文件数据的压缩和解压

```java
package com.github.binarylei.t3.util;

import java.io.*;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

/**
 * 文件数据压缩后再传输
 */
public class GzipUtils {
    public GzipUtils() {
    }

    public static byte[] gzip(byte[] data) throws Exception {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        GZIPOutputStream gzip = new GZIPOutputStream(bos);
        gzip.write(data);
        gzip.finish();
        gzip.close();
        byte[] ret = bos.toByteArray();
        bos.close();
        return ret;
    }

    public static byte[] ungzip(byte[] data) throws Exception {
        ByteArrayInputStream bis = new ByteArrayInputStream(data);
        GZIPInputStream gzip = new GZIPInputStream(bis);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        byte[] buf = new byte[1024];
        int len = -1;
        while((len = gzip.read(buf, 0, buf.length)) != -1) {
            bos.write(buf, 0, len);
        }

        gzip.close();
        bis.close();
        byte[] ret = bos.toByteArray();
        bos.flush();
        bos.close();
        return ret;
    }

    public static void main(String[] args) throws Exception {
        String readPath = System.getProperty("user.dir") + File.separatorChar + "public" + File.separatorChar + "sunset.jpg";
        FileInputStream in = new FileInputStream(new File(readPath));
        byte[] data = new byte[in.available()];
        in.read(data);
        in.close();
        System.out.println("文件原始大小:" + data.length);

        byte[] ret1 = gzip(data);
        System.out.println("压缩之后大小:" + ret1.length);

        byte[] ret2 = ungzip(ret1);
        System.out.println("还原之后大小:" + ret2.length);

        String writePath = System.getProperty("user.dir") + File.separatorChar + "public" + File.separatorChar + "sunset_2.jpg";
        FileOutputStream fos = new FileOutputStream(writePath);
        fos.write(ret2);
        fos.close();
    }
}
```

2. Request 添加文件

```java
//请求数据
public class Request implements Serializable{
    private String id ;
    private String name ;
    private String requestMessage ;
    private byte[] attachment;//传输文件
}
```

3. Client 发送文件

```java
public class Client {
    public static void main(String[] args) {
        //... f = b.connect("127.0.0.1", 8765).sync();
        //发送数据，传输文件 目前文件太大无法传输
        Request request = new Request("" + 4, "name-" + 4, "requestMessage-" + 4);
        String readPath = System.getProperty("user.dir") + File.separatorChar + "public" + File.separatorChar + "1.png";
        FileInputStream in = new FileInputStream(new File(readPath));
        byte[] data = new byte[in.available()];
        in.read(data);
        
        //文件在进行网络传输时，一般要先压缩
        request.setAttachment(GzipUtils.gzip(data));
        f.channel().writeAndFlush(request);
        
        in.close();
    }
}
```

4. ServerHandler 接收文件

```java
public class ServerHandler extends ChannelHandlerAdapter {
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
    
        //1. 接收 client 的请求
        Request req = (Request)msg;
        System.out.println(req);
    
        //2. 接收 client 发送的文件
        byte[] data = req.getAttachment();
        if (data != null) {
            try {
                byte[] ret2 = GzipUtils.ungzip(data);
                System.out.println("还原之后大小:" + ret2.length);
    
                String writePath = System.getProperty("user.dir") + File.separatorChar + "public" + File.separatorChar + "sunset_2.jpg";
                FileOutputStream fos = new FileOutputStream(writePath);
                fos.write(ret2);
                fos.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```