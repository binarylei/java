## 2.1 Netty初步

> [Netty](http://netty.io/) 是一个提供异步事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络服务器和客户端程序。更多请参考：[Netty Github](https://github.com/netty/netty) 和 [Netty中文入门](http://ifeve.com/netty5-user-guide/)。
  
![Netty架构](img/2.1.1components.png)

### 2.1.1 Netty 之 HelloWorld 

1. 服务器端 [com.github.binarylei.helloword]

```java
package com.github.binarylei.helloword;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

public class Server {
    private int port;

    public Server(int port) {
        this.port = port;
    }

    public void run() throws Exception {
        //1. 第一个线程组是用于接收Client端连接
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        //2. 第二个线程组是用于处理实现的业务操作
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            //3. ServerBootstrap 是一个启动NIO服务的辅助启动类
            ServerBootstrap b = new ServerBootstrap();
            //3.1 将两个工作线程组加进来
            b.group(bossGroup, workerGroup)
                //3.2 指定使用NioServerSocketChannel这种类型的通道
                .channel(NioServerSocketChannel.class)
                //3.3 使用childHandler来绑定具体的事件处理器
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    public void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline().addLast(new ServerHandler());
                    }
                })
                //3.4 设置TCP缓冲区大小，默认128，一般不用改
                .option(ChannelOption.SO_BACKLOG, 128)
                //3.5 设置发送缓冲区大小
                .option(ChannelOption.SO_SNDBUF, 32 * 1034)
                //3.6 设置接收缓冲区大小
                .option(ChannelOption.SO_RCVBUF, 32 * 1034)
                //3.7 KEEPALIVE
                .childOption(ChannelOption.SO_KEEPALIVE, true);

            //4. 绑定端口
            ChannelFuture f = b.bind(port).sync(); // (7)

            //5. 监听通道关闭  <=>  阻塞程序，不然Server直接执行完成后关闭，client就不可能连接上了
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        int port;
        if (args.length > 0) {
            port = Integer.parseInt(args[0]);
        } else {
            port = 8080;
        }
        new Server(port).run();
    }
}
```

2. 服务器端业务处理ServerHandler

```java
package com.github.binarylei.helloword;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerAdapter;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.ReferenceCountUtil;

import java.io.UnsupportedEncodingException;

public class ServerHandler extends ChannelHandlerAdapter {

    @Override
    //ctx.write()后自动释放msg
    public void channelRead(ChannelHandlerContext ctx, Object msg) {

        //读取buf中的数据
        ByteBuf buf = (ByteBuf) msg;
        byte[] data = new byte[buf.readableBytes()];
        buf.readBytes(data);

        System.out.println(new String(data));

        //写给客户端
        ChannelFuture f = ctx.writeAndFlush(Unpooled.copiedBuffer("netty".getBytes()));
        //写完成后会自动关闭 client，否则与 client 建立长连接 
        f.addListener(ChannelFutureListener.CLOSE);

        /*f.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                assert f == future;
                ctx.close();
            }
        });*/
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
```

3. 客户端

```java
package com.github.binarylei.helloword;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;

public class Client {
    
    public static void main(String[] args) throws InterruptedException {
        EventLoopGroup workgroup = new NioEventLoopGroup();
        try {
            Bootstrap b = new Bootstrap();
            b.group(workgroup)
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel sc) throws Exception {
                        sc.pipeline().addLast(new ClientHandler());
                    }
                });

            ChannelFuture f = b.connect("127.0.0.1", 8080).sync();

            //向服务器发送数据 buf
            f.channel().writeAndFlush(Unpooled.copiedBuffer("777".getBytes()));

            f.channel().closeFuture().sync();
        }  finally {
            workgroup.shutdownGracefully();
        }
    }
}
```

4. 客户端业务处理ClientHandler

```java
package com.github.binarylei.helloword;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerAdapter;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.ReferenceCountUtil;

public class ClientHandler extends ChannelHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) { // (2)
        try {
            //读取buf中的数据
            ByteBuf buf = (ByteBuf) msg;
            byte[] data = new byte[buf.readableBytes()];
            buf.readBytes(data);

            System.out.println(new String(data));
        } finally {
            //释放 (ByteBuf) msg
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
```

## 总结

* [io.netty.example.telnet](http://netty.io/5.0/xref/io/netty/example/telnet/package-summary.html)
