# 20.3 Java 设计模式系列教程（二十）享元模式之扩展

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[20.1 Java 设计模式系列教程（二十）享元模式之原理](20.1%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E7%90%86.md)

[20.2 Java 设计模式系列教程（二十）享元模式之场景分析](20.2%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90.md)

[20.3 Java 设计模式系列教程（二十）享元模式之扩展](20.3%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%89%A9%E5%B1%95.md)

## 20.3.1 结合原型模式 [demo3](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/flyweight/demo3)

在原发器对象创建备忘录对象的时候，如果原发器对象中全部或者大部分的状态都需要保存，一个简洁的方式就是直接克隆一个原发器对象。也就是说，这个时候备忘录对象里面存放的是一个原发器对象的实例。

还是通过示例来说明。只需要修改原发器对象就可以了，大致有如下变化：

1. 首先原发器对象要实现可克隆的，好在这个原发器对象的状态数据都很简单，都是基本数据类型，所以直接用默认的克隆方法就可以了，不用自己实现克隆，更不涉及深度克隆，否则，正确实现深度克隆还是个问题
2. 备忘录对象的实现要修改，只需要存储原发器对象克隆出来的实例对象就可以了
3. 相应的创建和设置备忘录对象的地方都要做修改

示例代码如下：

```java
/**
 * 模拟运行流程A，只是一个示意，代指某个具体流程
 */
public class FlowAMockPrototype implements Cloneable {
    /**
     * 流程名称，不需要外部存储的状态数据
     */
    private String flowName;
    /**
     * 示意，代指某个中间结果，需要外部存储的状态数据
     */
    private int tempResult;
    /**
     * 示意，代指某个中间结果，需要外部存储的状态数据
     */
    private String tempState;
    /**
     * 构造方法，传入流程名称
     * @param flowName 流程名称
     */
    public FlowAMockPrototype(String flowName){
        this.flowName = flowName;
    }
    /**
     * 示意，运行流程的第一个阶段
     */
    public void runPhaseOne(){
        //在这个阶段，可能产生了中间结果，示意一下
        tempResult = 3;
        tempState = "PhaseOne";
    }
    /**
     * 示意，按照方案一来运行流程后半部分
     */
    public void schema1(){
        //示意，需要使用第一个阶段产生的数据
        this.tempState += ",Schema1";
        System.out.println(this.tempState + " : now run "+tempResult);
        this.tempResult += 11;
    }
    /**
     * 示意，按照方案二来运行流程后半部分
     */
    public void schema2(){
        //示意，需要使用第一个阶段产生的数据
        this.tempState += ",Schema2";
        System.out.println(this.tempState + " : now run "+tempResult);
        this.tempResult += 22;
    }
    /**
     * 创建保存原发器对象的状态的备忘录对象
     * @return 创建好的备忘录对象
     */
    public FlowAMockflyweight createflyweight() {
        try {
            return new flyweightImplPrototype((FlowAMockPrototype) this.clone());
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }
    /**
     * 重新设置原发器对象的状态，让其回到备忘录对象记录的状态
     * @param flyweight 记录有原发器状态的备忘录对象
     */
    public void setflyweight(FlowAMockflyweight flyweight) {
        flyweightImplPrototype flyweightImpl = (flyweightImplPrototype)flyweight;
        this.tempResult = flyweightImpl.getFlowAMock().tempResult;
        this.tempState = flyweightImpl.getFlowAMock().tempState;
    }
    /**
     * 真正的备忘录对象，实现备忘录窄接口
     * 实现成私有的内部类，不让外部访问
     */
    private static class flyweightImplPrototype implements FlowAMockflyweight{
        private FlowAMockPrototype flowAMock = null;

        public flyweightImplPrototype(FlowAMockPrototype f){
            this.flowAMock = f;
        }

        public FlowAMockPrototype getFlowAMock() {
            return flowAMock;
        }
    }
}
```

好了，结合原型模式来实现享元模式的示例就写好了，在前面的客户测试程序中，创建原发器对象的时候，使用这个新实现的原发器对象就可以了。去测试和体会一下，看看是否能正确实现需要的功能。

不过要注意一点，就是如果克隆对象非常复杂，或者需要很多层次的深度克隆，实现克隆的时候会比较麻烦。

## 20.3.2 离线存储 [demo3](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/flyweight/demo3)

标准的享元模式，没有讨论离线存储的实现。

事实上，从享元模式的功能和实现上，是可以把备忘录的数据实现成为离线存储的，也就是不仅限于存储于内存中，可以把这些备忘数据存储到文件中、xml中、数据库中，从而支持跨越会话的备份和恢复功能。

离线存储甚至能帮助应对应用崩溃，然后关闭重启的情况，应用重启过后，从离线存储里面获取相应的数据，然后重新设置状态，恢复到崩溃前的状态。

当然，并不是所有的备忘数据都需要离线存储，一般来讲，需要存储很长时间、或者需要支持跨越会话的备份和恢复功能、或者是希望系统关闭后还能被保存的备忘数据，这些情况建议采用离线存储。

离线存储的实现也很简单，就以前面模拟运行流程的应用来说，如果要实现离线存储，主要需要修改管理者对象，把它保存备忘录对象的方法，实现成为保存到文件中，而恢复备忘录对象实现成为读取文件就可以了。对于其它相关对象，主要是要实现序列化，只有可序列化的对象才能被存储到文件中。

如果实现保存备忘录对象到文件，就不用在内存中保存了，去掉用来“记录被保存的备忘录对象”的这个属性。示例代码如下：

```java
/**
 * 负责在文件中保存模拟运行流程A的对象的备忘录对象
 */
public class FlowAflyweightFileCareTaker {

    /**
     * 保存备忘录对象
     * @param flyweight 被保存的备忘录对象
     */
    public void saveflyweight(FlowAMockflyweight flyweight){
        //写到文件中
        ObjectOutputStream out = null;
        try{
            out = new ObjectOutputStream(
                    new BufferedOutputStream(
                            new FileOutputStream("FlowAflyweight")
                    )
            );
            out.writeObject(flyweight);
        }catch(Exception err){
            err.printStackTrace();
        }finally{
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    /**
     * 获取被保存的备忘录对象
     * @return 被保存的备忘录对象
     */
    public FlowAMockflyweight retriveflyweight(){
        FlowAMockflyweight flyweight = null;
        //从文件中获取备忘录数据
        ObjectInputStream in = null;
        try{
            in = new ObjectInputStream(
                    new BufferedInputStream(
                            new FileInputStream("FlowAflyweight")
                    )
            );
            flyweight = (FlowAMockflyweight)in.readObject();
        }catch(Exception err){
            err.printStackTrace();
        }finally{
            try {
                in.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return flyweight;
    }
}
```

同时需要让备忘录对象的窄接口继承可序列化接口，示例代码如下：

```java
/**
 * 模拟运行流程A的对象的备忘录接口，是个窄接口
 */
public interface FlowAMockflyweight extends Serializable {
    //空的
}
```

好了，保存到文件的存储就实现好了，在前面的客户测试程序中，创建管理者对象的时候，使用这个新实现的管理者对象就可以了。去测试和体会一下。

## 20.3.3 再次实现可撤销操作 [demo4](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/flyweight/demo4)

在命令模式中，讲到了可撤销的操作，有两种基本的思路来实现可撤销的操作：

1. 一种是补偿式或者反操作式：比如被撤销的操作是加的功能，那撤消的实现就变成减的功能；同理被撤销的操作是打开的功能，那么撤销的实现就变成关闭的功能。

2. 另外一种方式是存储恢复式：意思就是把操作前的状态记录下来，然后要撤销操作的时候就直接恢复回去就可以了。

这里就该来实现第二种方式，就是存储恢复式，为了让大家更好的理解可撤销操作的功能，还是用原来的那个例子，对比学习会比较清楚。

这也相当于是命令模式和享元模式结合的一个例子，而且由于命令列表的存在，对应保存的备忘录对象也是多个。

http://sishuok.com/forum/blogPost/list/5634.html

## 20.3.4  相关模式

* 享元模式与单例模式

    这两个模式可以组合使用。

    通常情况下，享元模式中的享元工厂可以实现成为单例。另外，享元工厂里面缓存的享元对象，都是单实例的，可以看成是单例模式的一种变形控制，在享元工厂里面来单例享元对象。

* 享元模式与组合模式

    这两个模式可以组合使用。

    在享元模式里面，存在不需要共享的享元实现，这些不需要共享的享元通常是对共享的享元对象的组合对象，也就是说，享元模式通常会和组合模式组合使用，来实现更复杂的对象层次结构。

* 享元模式与状态模式

    这两个模式可以组合使用。

    可以使用享元模式来共享状态模式中的状态对象，通常在状态模式中，会存在数量很大的、细粒度的状态对象，而且它们基本上都是可以重复使用的，都是用来处理某一个固定的状态的，它们需要的数据通常都是由上下文传入，也就是变化部分都分离出去了，所以可以用享元模式来实现这些状态对象。

* 享元模式与策略模式

    这两个模式可以组合使用。

    可以使用享元模式来实现策略模式中的策略对象，跟状态模式一样，在策略模式中也存在大量细粒度的策略对象，它们需要的数据同样是从上下文传入的，所以可以使用享元模式来实现这些策略对象