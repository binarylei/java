# 15.3 Java 设计模式系列教程（十五）组合模式之扩展

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[15.1 Java 设计模式系列教程（十五）组合模式之原理]()

[15.2 Java 设计模式系列教程（十五）组合模式之场景分析]()

[15.3 Java 设计模式系列教程（十五）组合模式之扩展]()

## 15.3.1 安全性和透明性

根据前面的讲述，在组合模式中，把组件对象分成了两种，一种是可以包含子组件的Composite对象，一种是不能包含其它组件对象的叶子对象。

Composite对象就像是一个容器，可以包含其它的Composite对象或叶子对象。当然有了容器，就要能对这个容器进行维护，需要向里面添加对象，并能够从容器里面获取对象，还有能从容器中删除对象，也就是说需要管理子组件对象。

这就产生了一个很重要的问题：到底在组合模式的类层次结构中，在哪一些类里面定义这些管理子组件的操作，到底应该在Component中声明这些操作，还是在Composite中声明这些操作？

这就需要仔细思考，在不同的实现中，进行安全性和透明性的权衡选择。

这里所说的安全性是指：从客户使用组合模式上看是否更安全。如果是安全的，那么不会有发生误操作的可能，能访问的方法都是被支持的功能。
这里所说的透明性是指：从客户使用组合模式上，是否需要区分到底是组合对象还是叶子对象。如果是透明的，那就是不再区分，对于客户而言，都是组件对象，具体的类型对于客户而言是透明的，是客户无需要关心的。

### 1：透明性的实现

如果把管理子组件的操作定义在Component中，那么客户端只需要面对Component，而无需关心具体的组件类型，这种实现方式就是透明性的实现。事实上，前面示例的实现方式都是这种实现方式。

但是透明性的实现是以安全性为代价的，因为在Component中定义的一些方法，对于叶子对象来说是没有意义的，比如：增加、删除子组件对象。而客户不知道这些区别，对客户是透明的，因此客户可能会对叶子对象调用这种增加或删除子组件的方法，这样的操作是不安全的。

组合模式的透明性实现，通常的方式是：在Component中声明管理子组件的操作，并在Component中为这些方法提供缺省的实现，如果是有子对象不支持的功能，缺省的实现可以是抛出一个例外，来表示不支持这个功能。

### 2：安全性的实现

如果把管理子组件的操作定义在Composite中，那么客户在使用叶子对象的时候，就不会发生使用添加子组件或是删除子组件的操作了，因为压根就没有这样的功能，这种实现方式是安全的。

但是这样一来，客户端在使用的时候，就必须区分到底使用的是Composite对象，还是叶子对象，不同对象的功能是不一样的。也就是说，这种实现方式，对客户而言就不是透明的了。

下面把用透明性方式实现的示例，改成用安全性的方式再实现一次，这样大家可以对比来看，可以更好的理解组合模式的透明性和安全性这两种实现方式。

先还是来看一下使用安全性方式实现示例的结构，如图15.6所示

![图15.6  使用组合模式的安全性实现方式来实现示例的结构示意图](img/15.6.jpg)

### 3：安全性代码实现 [demo5]()

（1）首先看看Component的定义，跟透明性的实现相比，安全性的实现方式，Component里面不再定义管理和操作子组件的方法，把相应的方法都去掉。示例代码如下：

```java
/**
 * 抽象的组件对象
 */
public abstract class Component {
    /**
     * 输出组件自身的名称
     */
    public abstract void printStruct(String preStr);
}
```

（2）Composite对象和Leaf对象的实现都没有任何的变化，这里就不去赘述了

（3）接下来看看客户端的实现，客户端的变化主要是要区分Composite对象和Leaf对象，而原来是不区分的，都是Component对象。示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //定义所有的组合对象
        Composite root = new Composite("服装");
        Composite c1 = new Composite("男装");
        Composite c2 = new Composite("女装");

        //定义所有的叶子对象
        Component leaf1 = new Leaf("衬衣");
        Component leaf2 = new Leaf("夹克");
        Component leaf3 = new Leaf("裙子");
        Component leaf4 = new Leaf("套装");
        //按照树的结构来组合组合对象和叶子对象
        root.addChild(c1);
        root.addChild(c2);

        c1.addChild(leaf1);
        c1.addChild(leaf2);

        c2.addChild(leaf3);
        c2.addChild(leaf4);

        //调用根对象的输出功能来输出整棵树
        root.printStruct("");
    }
}
```

从上面的示例可以看出，从实现上，透明性和安全性的实现差别并不是很大。

### 4：两种实现方式的选择

对于组合模式而言，在安全性和透明性上，会更看重透明性，毕竟组合模式的功能就是要让用户对叶子对象和组合对象的使用具有一致性。

而且对于安全性的实现，需要区分是组合对象还是叶子对象，但是有的时候，你需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。

对于这种情况的处理方法是在Component里面定义一个getComposite的方法，用来判断是组合对象还是叶子对象，如果是组合对象，就返回组合对象，如果是叶子对象，就返回null，这样就可以先判断，然后再强制转换。

因此在使用组合模式的时候，建议多用透明性的实现方式，而少用安全性的实现方式。

## 15.3.2 父组件引用

在上面的示例中，都是在父组件对象里面，保存有子组件的引用，也就是说都是从父到子的引用。而本节来讨论一下子组件对象到父组件对象的引用，这个在实际开发中也是非常有用的，比如：

1. 现在要删除某个商品类别。如果这个类别没有子类别的话，直接删除就好了，没有太大的问题，但是如果它还有子类别，这就涉及到它的子类别如何处理了，一种情况是连带全部删除，一种是上移一层，把被删除的商品类别对象的父商品类别，设置成为被删除的商品类别的子类别的父商品类别。

2. 现在要进行商品类别的细化和调整，把原本属于A类别的一些商品类别，调整到B类别里面去，某个商品类别的调整会伴随着它所有的子类别一起调整。这样的调整可能会：把原本是兄弟关系的商品类别变成父子关系，也可能会把原本是父子关系的商品类别调整成了兄弟关系，如此等等会有很多种可能。

要实现上述的功能，一个较为简单的方案就是在保持从父组件到子组件引用的基础上，再增加保持从子组件到父组件的引用，这样在删除一个组件对象或是调整一个组件对象的时候，可以通过调整父组件的引用来实现，这可以大大简化实现。

通常会在Component中定义对父组件的引用，组合对象和叶子对象都可以继承这个引用。那么什么时候来维护这个引用呢？

较为容易的办法就是：在组合对象添加子组件对象的时候，为子组件对象设置父组件的引用；在组合对象删除一个子组件对象的时候，再重新设置相关子组件的父组件引用。把这些实现到Composite中，这样所有的子类都可以继承到这些方法，从而更容易的维护子组件到父组件的引用。

还是看示例会比较清楚。在前面实现的商品类别的示例基础上，来示例对父组件的引用，并实现删除某个商品类别，然后把被删除的商品类别对象的父商品类别，设置成为被删除的商品类别的子类别的父商品类别。也就是把被删除的商品类别对象的子商品类别都上移一层。

### 代码实现 [demo6]()

（1）先看看Component组件的定义，大致有如下变化：

1. 添加一个属性来记录组件对象的父组件对象，同时提供相应的getter/setter方法来访问父组件对象
2. 添加一个能获取一个组件所包含的子组件对象的方法，提供给实现当某个组件被删除时，把它的子组件对象上移一层的功能时使用

示例代码如下：

```java
/**
 * 抽象的组件对象
 */
public abstract class Component {
    /**
     * 记录父组件对象
     */
    private Component parent = null;

    /**
     * 获取一个组件的父组件对象
     * @return 一个组件的父组件对象
     */
    public Component getParent() {
        return parent;
    }
    /**
     * 设置一个组件的父组件对象
     * @param parent 一个组件的父组件对象
     */
    public void setParent(Component parent) {
        this.parent = parent;
    }
    /**
     * 返回某个组件的子组件对象
     * @return 某个组件的子组件对象
     */
    public List<Component> getChildren() {
        throw new UnsupportedOperationException("对象不支持这个功能");
    }

    /*-------------------以下是原有的定义----------------------*/

    /**
     * 输出组件自身的名称
     */
    public abstract void printStruct(String preStr);

    /**
     * 向组合对象中加入组件对象
     * @param child 被加入组合对象中的组件对象
     */
    public void addChild(Component child) {
        // 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
        throw new UnsupportedOperationException("对象不支持这个功能");
    }

    /**
     * 从组合对象中移出某个组件对象
     * @param child 被移出的组件对象
     */
    public void removeChild(Component child) {
        // 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
        throw new UnsupportedOperationException("对象不支持这个功能");
    }

    /**
     * 返回某个索引对应的组件对象
     * @param index 需要获取的组件对象的索引，索引从0开始
     * @return 索引对应的组件对象
     */
    public Component getChildren(int index) {
        throw new UnsupportedOperationException("对象不支持这个功能");
    }
}
```

（2）接下来看看Composite的实现，大致有如下变化：

1. 在添加子组件的方法实现里面，加入对父组件的引用实现
2. 在删除子组件的方法实现里面，加入把被删除的商品类别对象的父商品类别，设置成为被删除的商品类别的子类别的父商品类别的功能
3. 实现新的返回组件的子组件对象的功能

示例代码如下：

```java
/**
 * 组合对象，可以包含其它组合对象或者叶子对象
 */
public class Composite extends Component{

    public void addChild(Component child) {
        //延迟初始化
        if (childComponents == null) {
            childComponents = new ArrayList<Component>();
        }
        childComponents.add(child);

        //添加对父组件的引用
        child.setParent(this);
    }

    public void removeChild(Component child) {
        if (childComponents != null) {
            //查找到要删除的组件在集合中的索引位置
            int idx = childComponents.indexOf(child);
            if (idx != -1) {
                //先把被删除的商品类别对象的父商品类别，设置成为被删除的商品类别的子类别的父商品类别
                for(Component c : child.getChildren()){
                    //删除的组件对象是本实例的一个子组件对象
                    c.setParent(this);
                    //把被删除的商品类别对象的子组件对象添加到当前实例中
                    childComponents.add(c);
                }

                //真的删除
                childComponents.remove(idx);
            }
        }
    }

    public List<Component> getChildren() {
        return childComponents;
    }

    /*-------------------以下是原有的实现，没有变化----------------------*/

    /**
     * 用来存储组合对象中包含的子组件对象
     */
    private List<Component> childComponents = null;
    
    /**
     * 组合对象的名字
     */
    private String name = "";
    
    /**
     * 构造方法，传入组合对象的名字
     * @param name 组合对象的名字
     */
    public Composite(String name){
        this.name = name;
    }
    
    /**
     * 输出组合对象自身的结构
     * @param preStr 前缀，主要是按照层级拼接的空格，实现向后缩进
     */
    public void printStruct(String preStr){
        //先把自己输出去
        System.out.println(preStr+"+"+this.name);
        //如果还包含有子组件，那么就输出这些子组件对象
        if(this.childComponents!=null){
            //然后添加一个空格，表示向后缩进一个空格
            preStr+=" ";
            //输出当前对象的子对象了
            for(Component c : childComponents){
                //递归输出每个子对象
                c.printStruct(preStr);
            }
        }
    }
}
```

（3）叶子对象没有任何的改变，这里就不去赘述了

（4）可以来写个客户端测试一下了，在原来的测试后面，删除一个节点，然后再次输出整棵树的结构，看看效果。示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //定义所有的组合对象
        Component root = new Composite("服装");
        Component c1 = new Composite("男装");
        Component c2 = new Composite("女装");

        //定义所有的叶子对象
        Component leaf1 = new Leaf("衬衣");
        Component leaf2 = new Leaf("夹克");
        Component leaf3 = new Leaf("裙子");
        Component leaf4 = new Leaf("套装");

        //按照树的结构来组合组合对象和叶子对象
        root.addChild(c1);
        root.addChild(c2);

        c1.addChild(leaf1);
        c1.addChild(leaf2);
        c2.addChild(leaf3);
        c2.addChild(leaf4);

        //调用根对象的输出功能来输出整棵树
        root.printStruct("");

        System.out.println("---------------------------->");

        //然后删除一个节点
        root.removeChild(c1);
        //重新输出整棵树
        root.printStruct("");
    }
}
```

运行结果如下：

```
+服装
 +男装
  -衬衣
  -夹克
 +女装
  -裙子
  -套装
---------------------------->
+服装
 +女装
  -裙子
  -套装
 -衬衣
 -夹克
```

仔细观察上面的结果，当男装的节点被删除后，会把原来男装节点下的子节点，添加到原来男装的父节点，也就是服装的下面了。输出是按照添加的先后顺序来的，所以先输出了女装的，然后才是衬衣和夹克节点。

## 15.3.3 环状引用

所谓环状引用指的是：在对象结构中，某个对象包含的子对象，或是子对象的子对象，或是子对象的子对象的子对象……,如此经过N层后，出现所包含的子对象中有这个对象本身，从而构成了环状引用。比如：A包含B，B包含C，而C又包含了A，转了一圈，转回来了，就构成了一个环状引用。

这个在使用组合模式构建树状结构的时候，是需要考虑的一种情况。通常情况下，组合模式构建的树状结构，是不应该出现环状引用的，如果出现了，多半是有错误发生了。因此在应用组合模式实现功能的时候，就应该考虑要检测并避免出现环状引用，否则很容易引起死循环的操作，或是同一个功能被操作多次。

但是要说明的是：组合模式的实现里面也是可以有环状引用的，当然需要特殊构建环状引用，并提供相应的检测和处理，这里不去讨论这种情况。

那么该如何检测是否有环状引用的情况发生呢？

一个很简单的思路就是记录下每个组件从根节点开始的路径，因为要出现环状引用，在一条路径上，某个对象就必然会出现两次。因此只要每个对象在整个路径上只是出现了一次，那么就不会出现环状引用。

这个判断的功能可以添加到Composite对象的添加子组件的方法中，如果是环状引用的话，就抛出例外，并不会把它加入到子组件中去。

还是通过示例来说明吧。在前面实现的商品类别的示例基础上，来加入对环状引用的检测和处理。约定用组件的名称来代表组件，也就是说，组件的名称是唯一的，不会重复的，只要检测在一条路径上，组件名称不会重复，那么组件就不会重复。

### 代码实现 [demo7]()

（1）先看看Component的定义，大致有如下的变化：

1. 添加一个记录每个组件的路径的属性，并提供相应的getter/setter方法
2. 为了拼接组件的路径，新添加一个方法来获取组件的名称

示例代码如下：

```java
/**
 * 抽象的组件对象
 */
public abstract class Component {
    /**
     * 记录每个组件的路径
     */
    private String componentPath = "";

    /**
     * 获取组件的路径
     * @return 组件的路径
     */
    public String getComponentPath() {
        return componentPath;
    }

    /**
     * 设置组件的路径
     * @param componentPath 组件的路径
     */
    public void setComponentPath(String componentPath) {
        this.componentPath = componentPath;
    }
    /*---------------以下是原有的实现，没有变化------------------*/
}
```

（2）再看看Composite的实现，大致有如下的变化：

1. 提供获取组件名称的实现
2. 在添加子组件的实现方法里面，进行是否环状引用的判断，并计算组件对象的路径，然后设置回组件对象去

示例代码如下：

```java
public class Composite extends Component{

    public String getName(){
        return this.name;
    }

    public void addChild(Component child) {
        //延迟初始化
        if (childComponents == null) {
            childComponents = new ArrayList<Component>();
        }
        childComponents.add(child);

        //1 先判断组件路径是否为空，如果为空，说明本组件是根组件
        if(this.getComponentPath() == null || this.getComponentPath().trim().length() == 0){
            //把本组件的name设置到组件路径中
            this.setComponentPath(this.name);
        }
        //判断要加入的组件在路径上是否出现过
        //先判断是否是根组件
        if(this.getComponentPath().startsWith(child.getName() + ".")){
            //说明是根组件，重复添加了
            throw new java.lang.IllegalArgumentException("在本通路上，组件 '" + child.getName() + "' 已被添加过了");
        }else{
            if(this.getComponentPath().indexOf("." + child.getName()) < 0){
                //表示没有出现过,那么可以加入
                //计算组件的路径
                String componentPath = this.getComponentPath() + "." + child.getName();
                //设置子组件的路径
                child.setComponentPath(componentPath);
            }else{
                throw new java.lang.IllegalArgumentException("在本通路上，组件 '"+child.getName()+"' 已被添加过了");
            }
        }
    }

    /*---------------以下是原有的实现，没有变化------------------*/
}
```

（3）叶子对象的实现，只是多了一个实现获取组件名称的方法，也就是直接返回叶子对象的Name，跟Composite中的实现是类似的，就不去代码示例了

（4）客户端的代码可以不做修改，可以正常执行，输出商品类别树来。当然，如果想要看到环状引用检测的效果，你可以做一个环状引用测试看看，比如：

```java
public class Client {
    public static void main(String[] args) {
        //定义所有的组合对象
        Component root = new Composite("服装");
        Component c1 = new Composite("男装");
        Component c2= new Composite("衬衣");
        Component c3= new Composite("男装");
        //设置一个环状引用
        root.addChild(c1);
        c1.addChild(c2);
        c2.addChild(c3);

        //调用根对象的输出功能来输出整棵树
        root.printStruct("");
    }
}
```

运行结果如下：

```
Exception in thread "main" java.lang.IllegalArgumentException: 在本通路上，组件 '男装' 已被添加过了
```

## 15.3.4 相关模式

### 组合模式和装饰模式
    
这两个模式可以组合使用。

装饰模式在组装多个装饰器对象的时候，是一个装饰器找下一个装饰器，下一个再找下一个，如此递归下去。那么这种结构也可以使用组合模式来帮助构建，这样一来，装饰器对象就相当于组合模式的Composite对象了。
    
要让两个模式能很好的组合使用，通常会让它们有一个公共的父类，因此装饰器必须支持组合模式需要的一些功能，比如：增加、删除子组件等等。

### 组合模式和享元模式

这两个模式可以组合使用。

如果组合模式中出现大量相似的组件对象的话，可以考虑使用享元模式来帮助缓存组件对象，这可以减少对内存的需要。

使用享元模式也是有条件的，如果组件对象的可变化部分的状态能够从组件对象里面分离出去，而且组件对象本身不需要向父组件发送请求的话，就可以采用享元模式。

### 组合模式和迭代器模式

这两个模式可以组合使用。

在组合模式中，通常可以使用迭代器模式来遍历组合对象的子对象集合，而无需关心具体存放子对象的聚合结构。

### 组合模式和访问者模式

这两个模式可以组合使用。

访问者模式能够在不修改原有对象结构的情况下，给对象结构中的对象增添新的功能。将访问者模式和组合模式合用，可以把原本分散在Composite和Leaf类中的操作和行为都局部化。

如果在使用组合模式的时候，预计到今后可能会有增添其它功能的可能，那么可以采用访问者模式，来预留好添加新功能的方式和通道，这样以后在添加新功能的时候，就不需要再修改已有的对象结构和已经实现的功能了。

###　组合模式和职责链模式

这两个模式可以组合使用。

职责链模式要解决的问题是：实现请求的发送者和接收者之间解耦。职责链模式的实现方式是把多个接收者组合起来，构成职责链，然后让请求在这条链上传递，直到有接收者处理这个请求为止。

可以应用组合模式来构建这条链，相当于是子组件找父组件，父组件又找父组件，如此递归下去，构成一条处理请求的组件对象链。

### 组合模式和命令模式

这两个模式可以组合使用。

命令模式中有一个宏命令的功能，通常这个宏命令就是使用组合模式来组装出来的。