# 21.1 Java 设计模式系列教程（二一）解释器模式之原理

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%21Java%21%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[21.1 Java 设计模式系列教程（二一）解释器模式之原理](21.1%21Java%21%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E7%90%86.md)

[21.2 Java 设计模式系列教程（二一）解释器模式之场景分析](21.2%21Java%21%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90.md)

[21.3 Java 设计模式系列教程（二一）解释器模式之扩展](21.3%21Java%21%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%89%A9%E5%B1%95.md)

> 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。[interpreter](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/interpreter)

## 21.1.1 解释器模式结构

![图21.1 解释器模式结构示意图](img/21.1.jpg)

* `AbstractExpression`： 定义解释器的接口，约定解释器的解释操作。

* `TerminalExpression`：终结符解释器，用来实现语法规则中和终结符相关的操作，不再包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的叶子对象，可以有多种终结符解释器。

* `NonterminalExpression`：非终结符解释器，用来实现语法规则中非终结符相关的操作，通常一个解释器对应一个语法规则，可以包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的组合对象，可以有多种非终结符解释器。

* `Context`：上下文，通常包含各个解释器需要的数据，或是公共的功能。

* `Client`：客户端，指的是使用解释器的客户端，通常在这里去把按照语言的语法做的表达式，转换成为使用解释器对象描述的抽象语法树，然后调用解释操作。

## 21.1.2 解释器模式参考实现 [demo1](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/interpreter/demo1)

（1）先看看抽象表达式的定义，非常简单，定义一个执行解释的方法，示例代码如下：

```java
/**
 * 抽象表达式
 */
public abstract class AbstractExpression {
    /**
     * 解释的操作
     * @param ctx 上下文对象
     */
    public abstract void interpret(Context ctx);
}

```

（2）再来看看终结符表达式的定义，示例代码如下：

```java
/**
 * 终结符表达式
 */
public class TerminalExpression extends AbstractExpression{
    
    public void interpret(Context ctx) {
        //实现与语法规则中的终结符相关联的解释操作
    }
}
```

（3）接下来该看看非终结符表达式的定义了，示例代码如下：

```java
/**
 * 非终结符表达式
 */
public class NonterminalExpression extends AbstractExpression{
    public void interpret(Context ctx) {
        //实现与语法规则中的非终结符相关联的解释操作
    }
}
```

（4）上下文的定义，示例代码如下：

```java
/**
 * 上下文，包换解释器之外的一些全局信息
 */
public class Context {
}
```

（5）最后来看看客户端的定义，示例代码如下：

```java
/**
 * 使用解释器的客户
 */
public class Client {
    //主要按照语法规则对特定的句子构建抽象语法树
    //然后调用解释操作
}
```

看到这里，可能有些朋友会觉得，上面的示例代码里面什么都没有啊。这主要是因为解释器模式是跟具体的语法规则联系在一起的，没有相应的语法规则，自然写不出对应的处理代码来。

但是这些示例还是有意义的，可以通过它们看出解释器模式实现的基本架子，只是没有内部具体的处理罢了。

## 21.1.3 进一步认识解释器模式

#### （1）变与不变

解释器模式设计的重点就在于 **分离变与不变** ，把一个对象的状态分成内部状态和外部状态，内部状态是不变的，外部状态是可变的。然后通过共享不变的部分，达到减少对象数量、并节约内存的目的。在享元对象需要的时候，可以从外部传入外部状态给共享的对象，共享对象会在功能处理的时候，使用自己内部的状态和这些外部的状态。

事实上，分离变与不变是软件设计上最基本的方式之一，比如预留接口，为什么在这个地方要预留接口，一个常见的原因就是这里存在变化，可能在今后需要扩展、或者是改变已有的实现，因此预留接口做为“可插入性的保证”。

#### （2）共享与不共享

在解释器模式中，享元对象又有共享与不共享之分，这种情况通常出现在跟组合模式合用的情况，通常共享的是叶子对象，一般不共享的部分是由共享部分组合而成的，由于所有细粒度的叶子对象都已经缓存了，那么缓存组合对象就没有什么意义了。这个在后面给大家一个示例。

#### （3）内部状态和外部状态

解释器模式的内部状态，通常指的是包含在享元对象内部的、对象本身的状态，通常是独立于使用享元的场景的信息，一般创建过后就不再变化的状态，因此可以共享。

外部状态指的是享元对象之外的状态，取决于使用享元的场景，会根据使用场景而变化，因此不可共享。如果享元对象需要这些外部状态的话，可以从外部传递到享元对象里面，比如通过方法的参数来传递。

也就是说解释器模式真正缓存和共享的数据是享元的内部状态，而外部状态是不应该被缓存共享的。

另外一点，内部状态和外部状态是独立的，外部状态的变化不应该影响到内部状态。

#### （4）实例池

在解释器模式中，为了创建和管理共享的享元部分，引入了享元工厂，享元工厂中一般都包含有享元对象的实例池，享元对象就是缓存在这个实例池中的。

简单介绍一点实例池的知识， **所谓实例池，指的是缓存和管理对象实例的程序，通常实例池会提供对象实例的运行环境，并控制对象实例的生命周期。**

工业级的实例池实现上有两个最基本的难点，**一个就是动态控制实例数量，一个就是动态分配实例来提供给外部使用。** 这些都是需要算法来做保证的。

假如实例池里面已有了3个实例，但是客户端请求非常多，有些忙不过来，那么实例池的管理程序就应该判断出来，到底几个实例才能满足现在的客户需求，理想状况是刚刚好，就是既能够满足应用的需要，又不会造成对象实例的浪费，假如经过判断5个实例正好，那么实例池的管理程序就应该能动态的创建2个新的实例。

这样运行了一段时间，客户端的请求减少了，这个时候实例池的管理程序又应该动态的判断，究竟几个实例是最好的，多了明显浪费资源，假如经过判断只需要1个实例就可以了，那么实例池的管理程序应该销毁掉多余的4个实例，以释放资源。这就是动态控制实例数量。

对于动态分配实例，也说明一下吧，假如实例池里面有3个实例，这个时候来了一个新的请求，到底调度哪一个实例去执行客户的请求呢，如果有空闲实例，那就是它了，要是没有空闲实例呢，是新建一个实例，还是等待运行中的实例，等它运行完了就来处理这个请求呢？具体如何调度，也是需要算法来保障的。

回到解释器模式中来，享元工厂中的实例池可没有这么复杂，因为共享的享元对象基本上都是一个实例，一般不会出现同一个享元对象有多个实例的情况，这样就不用去考虑动态创建和销毁享元对象实例的功能；另外只有一个实例，也就不存在动态调度的麻烦，反正就是它了。

这也主要是因为享元对象封装的多半是对象的内部状态，这些状态通常是不变的，有一个实例就够了，不需要动态控制生命周期，也不需要动态调度，它只需要做一个缓存而已，没有上升到真正的实例池那么个高度。

#### （5）解释器模式的调用顺序示意图

解释器模式的使用上，有两种情况，一种是没有“不需要共享”的享元对象，就如同前面的示例那样，只有共享享元对象的情况；还有一种是既有共享享元对象，又有不需要共享的享元对象的情况，这种情况后面再示例。

这里看看只有共享享元对象的情况下，解释器模式的调用顺序，如图21.2所示：

![图21.2 只有共享享元对象的情况下解释器模式的调用顺序示意图](img/21.2.jpg)

#### （6）谁来初始化共享对象

在解释器模式中，通常是在第一次向享元工厂请求获取共享对象的时候，进行共享对象的初始化，而且多半都是在享元工厂内部实现，不会从外部传入共享对象。当然可以从外部传入一些创建共享对象需要的值，享元工厂可以按照这些值去初始化需要共享的对象，然后就把创建好的共享对象的实例放入享元工厂内部的缓存中，以后再请求这个共享对象的时候就不用再创建了。

## 21.1.4 总结

### 解释器模式的本质

解释器模式的本质： **分离与共享** 。

分离的是对象状态中变与不变的部分，共享的是对象中不变的部分。解释器模式的关键之处就在于分离变与不变，把不变的部分作为享元对象的内部状态，而变化部分就作为外部状态，由外部来维护，这样享元对象就能够被共享，从而减少对象数量，并节省大量的内存空间。

理解了这个本质后，在使用解释器模式的时候，就会去考虑，哪些状态需要分离？如何分离？分离后如何处理？哪些需要共享？如何管理共享的对象？外部如何使用共享的享元对象？是否需要不共享的对象？等等问题。

把这些问题都思考清楚，找到相应的解决方法，那么解释器模式也就应用起来了，可能是标准的应用，也可能是变形的应用，但万变不离其宗。

### 何时选用解释器模式

**建议在如下情况中，选用解释器模式：**

1. 如果一个应用程序使用了大量的细粒度对象，可以使用解释器模式来减少对象数量

2. 如果由于使用大量的对象，造成很大的存储开销，可以使用解释器模式来减少对象数量，并节约内存

3. 如果对象的大多数状态都可以转变为外部状态，比如通过计算得到，或是从外部传入等，可以使用解释器模式来实现内部状态和外部状态的分离

4. 如果不考虑对象的外部状态，可以用相对较少的共享对象取代很多组合对象，可以使用解释器模式来共享对象，然后组合对象来使用这些共享对象

### 解释器模式的优缺点

* 减少对象数量，节省内存空间

    可能有的朋友认为共享对象会浪费空间，但是如果这些对象频繁使用，那么其实是节省空间的。因为占用空间的大小等于每个对象实例占用的大小再乘以数量，对于享元对象来讲，基本上就只有一个实例，大大减少了享元对象的数量，并节省不少的内存空间。
    
    节省的空间取决于以下几个因素：因为共享而减少的实例数目、每个实例本身所占用的空间。假如每个对象实例占用2个字节，如果不共享数量是100个，而共享过后就只有一个了，那么节省的空间约等于：(100-1) X 2 字节。

* 维护共享对象，需要额外开销

    如同前面演示的享元工厂，在维护共享对象的时候，如果功能复杂，会有很多额外的开销，比如有一个线程来维护垃圾回收。