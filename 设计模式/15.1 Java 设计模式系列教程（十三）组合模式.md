# 15.1 Java 设计模式系列教程（十五）组合者模式之原理

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[15.1 Java 设计模式系列教程（十二）组合模式之原理]()

[15.2 Java 设计模式系列教程（十二）组合模式之场景分析]()

[15.3 Java 设计模式系列教程（十二）组合模式之扩展]()

> 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象的使用具有一致性。[demo]()

## 1. 组合模式原理

### 15.1.1 组合模式结构

![15.1组合模式结构示意图](img/15.1.jpg)

* `Component`： 抽象的组件对象，为组合中的对象声明接口，让客户端可以通过这个接口来访问和管理整个对象结构，可以在里面为定义的功能提供缺省的实现。

* `Leaf`： 叶子节点对象，定义和实现叶子对象的行为，不再包含其它的子节点对象。

* `Composite`： 组合对象，通常会存储子组件，定义包含子组件的那些组件的行为，并实现在组件接口中定义的与子组件有关的操作。

* `Client`： 客户端，通过组件接口来操作组合结构里面的组件对象。

一种典型的Composite对象结构通常是如图15.2所示的树形结构，一个Composite对象可以包含多个叶子多象和其它的Composite对象，虽然15.2的图看起来好像有些对称，但是那只是为了让图看起来美观一点，并不是说Composite组合的对象结构就是这样对称的，这点要提前说明一下。

![15.2典型的Composite对象结构](img/15.2.jpg)

### 15.1.2 组合模式参考实现 [demo1]()

（1）先看看组件对象的定义，示例代码如下：

```java
/**
 * 抽象的组件对象，为组合中的对象声明接口，实现接口的缺省行为
 */
public abstract class Component {

    /**
     * 示意方法，子组件对象可能有的功能方法
     */
    public abstract void someOperation();

    /**
     * 向组合对象中加入组件对象
     * @param child 被加入组合对象中的组件对象
     */
    public void addChild(Component child) {
        // 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
        throw new UnsupportedOperationException("对象不支持这个功能");
    }

    /**
     * 从组合对象中移出某个组件对象
     * @param child 被移出的组件对象
     */
    public void removeChild(Component child) {
        // 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
        throw new UnsupportedOperationException("对象不支持这个功能");
    }

    /**
     * 返回某个索引对应的组件对象
     * @param index 需要获取的组件对象的索引，索引从0开始
     * @return 索引对应的组件对象
     */
    public Component getChildren(int index) {
        // 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
        throw new UnsupportedOperationException("对象不支持这个功能");
    }
}
```

（2）接下来看看Composite对象的定义，示例代码如下：

```java
/**
 * 组合对象，通常需要存储子对象，定义有子部件的部件行为，
 * 并实现在Component里面定义的与子部件有关的操作
 */
public class Composite extends Component {
    /**
     * 用来存储组合对象中包含的子组件对象
     */
    private List<Component> childComponents = null;

    /**
     * 示意方法，通常在里面需要实现递归的调用
     */
    public void someOperation() {
        if (childComponents != null){
            for(Component c : childComponents){
                //递归的进行子组件相应方法的调用
                c.someOperation();
            }
        }
    }
    public void addChild(Component child) {
        //延迟初始化
        if (childComponents == null) {
            childComponents = new ArrayList<Component>();
        }
        childComponents.add(child);
    }

    public void removeChild(Component child) {
        if (childComponents != null) {
            childComponents.remove(child);
        }
    }

    public Component getChildren(int index) {
        if (childComponents != null){
            if(index>=0 && index<childComponents.size()){
                return childComponents.get(index);
            }
        }
        return null;
    }
}
```

（3）该来看叶子对象的定义了，相对而言比较简单，示例代码如下：

```java
/**
 * 叶子对象，叶子对象不再包含其它子对象
 */
public class Leaf extends Component {
    /**
     * 示意方法，叶子对象可能有自己的功能方法
     */
    public void someOperation() {
        // do something
    }

}
```

（4）对于Client，就是使用Component接口来操作组合对象结构，由于使用方式千差万别，这里仅仅提供一个示范性质的使用，顺便当作测试代码使用，示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //定义多个Composite对象
        Component root = new Composite();
        Component c1 = new Composite();
        Component c2 = new Composite();
        //定义多个叶子对象
        Component leaf1 = new Leaf();
        Component leaf2 = new Leaf();
        Component leaf3 = new Leaf();

        //组和成为树形的对象结构
        root.addChild(c1);
        root.addChild(c2);
        root.addChild(leaf1);

        c1.addChild(leaf2);
        c2.addChild(leaf3);

        //操作Component对象
        Component o = root.getChildren(1);
        System.out.println(o);
    }
}
```

## 15.1.3 进一步认识组合者模式

#### （1）组合模式的目的

组合模式的目的是：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。

实现这个目标的关键之处，是设计一个抽象的组件类，让它可以代表组合对象和叶子对象。这样一来，客户端就不用区分到底是组合对象还是叶子对象了，只需要全部当成组件对象进行统一的操作就可以了。

#### （2）对象树

通常，组合模式会组合出树形结构来，组成这个树形结构所使用的多个组件对象，就自然的形成了对象树。

这也意味着凡是可以使用对象树来描述或操作的功能，都可以考虑使用组合模式，比如读取XML文件，或是对语句进行语法解析等。

#### （3）组合模式中的递归

组合模式中的递归，指的是对象递归组合，不是常说的递归算法。通常我们谈的递归算法，是指“一个方法会调用方法自己”这样的算法，是从功能上来讲的，比如那个经典的求阶乘的例子，示例如下：

```java
public class RecursiveTest {
    /**
     * 示意递归算法，求阶乘。这里只是简单的实现，只能实现求数值较小的阶乘，
     * 对于数据比较大的阶乘，比如求100的阶乘应该采用java.math.BigDecimal
     * 或是java.math.BigInteger
     * @param a 求阶乘的数值
     * @return 该数值的阶乘值
     */
    public int recursive(int a){
       if(a==1){
           return 1;
       }     
       return a * recursive(a-1);
    }  

    public static void main(String[] args) {
       RecursiveTest test = new RecursiveTest();
       int result = test.recursive(5);
       System.out.println("5的阶乘="+result);
    }
}
```

而这里的组合模式中的递归，是对象本身的递归，是对象的组合方式，是从设计上来讲的，在设计上称作递归关联，是对象关联关系的一种，如果用UML来表示对象的递归关联的话，一对一的递归关联如图15.3所示

![图15.3  一对一递归关联结构示意图](img/15.3.jpg)

而一对多的递归关联如图15.4所示：

![图15.4  一对多递归关联结构示意图](img/15.4.jpg)

另外组合对象还有一个特点，就是理论上没有层次限制，组合对象A包含组合对象B，组合对象B又包含组合对象C……，这样下去是没有尽头的。因此在实现的时候，一个必然的选择就是递归实现。

#### （4）Component中是否应该实现一个Component列表

大多数情况下，一个Composite对象会持有子节点的集合。有些朋友可能就会想，那么能不能把这个子节点集合定义到Component中去呢？因为在Component中还声明了一些操作子节点的方法，这样一来，大部分的工作就可以在Component中完成了。

事实上，这种方法是不太好的，因为在父类来存放子类的实例对象，对于Composite节点来说没有什么，它本来就需要存放子节点，但是对于叶子节点来说，就会导致空间的浪费，因为叶节点本身不需要子节点。

因此只有当组合结构中叶子对象数目较少的时候，才值得使用这种方法。

#### （5）最大化Component定义

前面讲到了组合模式的目的是：让客户端不再区分操作的是组合对象还是叶子对象，而是以一种统一的方式来操作。

由于要统一两种对象的操作，所以Component里面的方法也主要是两种对象对外方法的和，换句话说，有点大杂烩的意思，组件里面既有叶子对象需要的方法，也有组合对象需要的方法。

其实 **这种实现是与类的设计原则相冲突的，类的设计有这样的原则：一个父类应该只定义那些对它的子类有意义的操作。** 但是看看上面的实现就知道，Component中的有些方法对于叶子对象是没有意义的。那么怎么解决这一冲突呢？

常见的做法是在Component里面为对某些子对象没有意义的方法，提供默认的实现，或是默认抛出不支持该功能的例外。这样一来，如果子对象需要这个功能，那就覆盖实现它，如果不需要，那就不用管了，使用父类的默认实现就可以了。

从另一个层面来说，如果把叶子对象看成是一个特殊的Composite对象，也就是没有子节点的组合对象而已。这样看来，对于Component而言，子对象就全部看作是组合对象，因此定义的所有方法都是有意义的了。

#### （6）子部件排序

在某些应用中，使用组合模式的时候，需要按照一定的顺序来使用子组件对象，比如进行语法分析的时候，使用组合模式构建的抽象语法树，在解析执行的时候，是需要按照顺序来执行的。

对于这样的功能，需要在设计的时候，就要把组件对象的索引考虑进去，并仔细的设计对子节点的访问和管理接口，通常的方式是需要按照顺序来存储，这样在获取的时候就可以按照顺序得到了。可以考虑结合Iterator模式来实现按照顺序的访问组件对象。

## 15.1.4 总结

### 观察者模式的本质

### 何时选用观察者模式

### 观察者模式的优缺点