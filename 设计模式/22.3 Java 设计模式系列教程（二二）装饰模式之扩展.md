# 22.3 Java 设计模式系列教程（二二）装饰器模式之扩展

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%22Java%22%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[22.1 Java 设计模式系列教程（二二）装饰器模式之原理](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.1%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E4%BA%8C%EF%BC%89%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E7%90%86.md)

[22.2 Java 设计模式系列教程（二二）装饰器模式之场景分析](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.2%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E4%BA%8C%EF%BC%89%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90.md)

[22.3 Java 设计模式系列教程（二二）装饰器模式之扩展](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.3%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E4%BA%8C%EF%BC%89%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%89%A9%E5%B1%95.md)

## 22.3.1 Java中的装饰模式应用

装饰模式在Java中最典型的应用，就是 I/O 流，简单回忆一下，如果使用流式操作读取文件内容，会怎么实现呢，简单的代码示例如下：

```java
public class IOTest {
    public static void main(String[] args)throws Exception  {
        //流式读取文件
        DataInputStream din = null;
        try{
            din = new DataInputStream(
                new BufferedInputStream(
                        new FileInputStream("IOTest.txt")
                )
            );
            //然后就可以获取文件内容了
            byte bs []= new byte[din.available()]; 
            din.read(bs);
            String content = new String(bs);
            System.out.println("文件内容===="+content);
        }finally{
            din.close();
        }       
    }
}
```

仔细观察上面的代码，会发现最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理过后，再把处理过后的对象传递给了DataInputStream对象进行处理，这个过程其实就是装饰器的组装过程，FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。

可能有朋友会问，装饰器和具体的组件类是要实现同样的接口的，上面这些类是这样吗？看看Java的I/O对象层次图吧，由于Java的I/O对象众多，因此只是画出了InputStream的部分，而且由于图的大小关系，也只是表现出了部分的流，具体如图22.4所示：

![图22.4 Java的I/O的InputStream部分对象层次图](img/22.4.jpg)

查看上图会发现，它的结构和装饰模式的结构几乎是一样的：

1. InputStream就相当于装饰模式中的Component。

2. 其实FileInputStream、ObjectInputStream、StringBufferInputStream这几个对象是直接继承了InputSream，还有几个直接继承InputStream的对象，比如：ByteArrayInputStream、PipedInputStream等。这些对象相当于装饰模式中的ConcreteComponent，是可以被装饰器装饰的对象。

3. 那么FilterInputStream就相当于装饰模式中的Decorator，而它的子类DataInputStream、BufferedInputStream、LineNumberInputStream和PushbackInputStream就相当于装饰模式中的ConcreteDecorator了。另外FilterInputStream和它的子类对象的构造器，都是传入组件InputStream类型，这样就完全符合前面讲述的装饰器的结构了。

同样的，输出流部分也类似，就不去赘述了。

既然I/O流部分是采用装饰模式实现的，也就是说，如果我们想要添加新的功能的话，只需要实现新的装饰器，然后在使用的时候，组合进去就可以了，也就是说，我们可以自定义一个装饰器，然后和JDK中已有的流的装饰器一起使用。能行吗？试试看吧，前面是按照输入流来讲述的，下面的示例按照输出流来做，顺便体会一下Java的输入流和输出流在结构上的相似性。

### 自己实现的I/O流的装饰器——第一版 [demo5](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/decorator/demo5)

来个功能简单点的，实现把英文加密存放吧，也谈不上什么加密算法，就是把英文字母向后移动两个位置，比如：a变成c，b变成d，以此类推，最后的y变成a，z就变成b，而且为了简单，只处理小写的，够简单的吧。

好了，还是看看实现简单的加密的代码实现吧，示例代码如下：

```java
/**
 * 实现简单的加密
 */
public class EncryptOutputStream  extends OutputStream{
    //持有被装饰的对象
    private OutputStream os = null;
    public EncryptOutputStream(OutputStream os){
        this.os = os;
    }
    
    public void write(int a) throws IOException {
        //先统一向后移动两位
        a = a+2;
        //97是小写的a的码值
        if(a >= (97+26)){
            //如果大于，表示已经是y或者z了，减去26就回到a或者b了
            a = a-26;
        }
        this.os.write(a);
    }
}
```

测试一下看看，好用吗？客户端使用代码示例如下：

```java
public class Client {
    public static void main(String[] args) throws Exception {
        //流式输出文件
        DataOutputStream dout = new DataOutputStream(
            new EncryptOutputStream(
                new BufferedOutputStream(
                    new FileOutputStream("MyEncrypt.txt"))));
        //然后就可以输出内容了
        dout.write("abcdxyz".getBytes());
        dout.close();
    }
}
```

运行一下，打开生成的文件，看看结果，结果示例如下：

```
cdefzab
```

很好，是不是被加密了，虽然是明文的，但已经不是最初存放的内容了，一切显得非常的完美。

再试试看，不是说装饰器可以随意组合吗，换一个组合方式看看，比如把BufferedOutputStream和我们自己的装饰器在组合的时候换个位，示例如下：

```java
public class Client {
    public static void main(String[] args) throws Exception {
        //流式输出文件
        DataOutputStream dout = new DataOutputStream(
            new BufferedOutputStream(
                new EncryptOutputStream(
                    new FileOutputStream("MyEncrypt.txt"))));
        //然后就可以输出内容了
        dout.write("abcdxyz".getBytes());
        dout.close();
    }
}
```

再次运行，看看结果。坏了，出大问题了，这个时候输出的文件一片空白，什么都没有。这是哪里出了问题呢？

要把这个问题搞清楚，就需要把上面I/O流的内部运行和基本实现搞明白，分开来看看具体的运行过程吧。

（1）先看看成功输出流中的内容的写法的运行过程：

1. 当执行到“dout.write("abcdxyz".getBytes());”这句话的时候，会调用DataOutputStream的write方法，把数据输出到BufferedOutputStream中；

2. 由于BufferedOutputStream流是一个带缓存的流，它默认缓存8192byte，也就是默认流中的缓存数据到了8192byte，它才会自动输出缓存中的数据；而目前要输出的字节肯定不到8192byte，因此数据就被缓存在BufferedOutputStream流中了，而不会被自动输出

3. 当执行到“dout.close();”这句话的时候：会调用关闭DataOutputStream流，这会转调到传入DataOutputStream中的流的close方法，也就是BufferedOutputStream的close方法，而BufferedOutputStream的close方法继承自FilterOutputStream，在FilterOutputStream的close方法实现里面，会先调用输出流的方法flush，然后关闭流。也就是此时BufferedOutputStream流中缓存的数据会被强制输出；

4. BufferedOutputStream流中缓存的数据被强制输出到EncryptOutputStream流，也就是我们自己实现的流，没有缓存，经过处理后继续输出；

5. EncryptOutputStream流会把数据输出到FileOutputStream中，FileOutputStream会直接把数据输出到文件中，因此，这种实现方式会输出文件的内容。

（2）再来看看不能输出流中的内容的写法的运行过程：

1. 当执行到“dout.write("abcdxyz".getBytes());”这句话的时候，会调用DataOutputStream的write方法，把数据输出到EncryptOutputStream中；
EncryptOutputStream流，也就是我们自己实现的流，没有缓存，经过处理后继续输出，把数据输出到BufferedOutputStream中；

2. 由于BufferedOutputStream流是一个带缓存的流，它默认缓存8192byte，也就是默认流中的缓存数据到了8192byte，它才会自动输出缓存中的数据；而目前要输出的字节肯定不到8192byte，因此数据就被缓存在BufferedOutputStream流中了，而不会被自动输出

3. 当执行到“dout.close();”这句话的时候：会调用关闭DataOutputStream流，这会转调到传入DataOutputStream流中的流的close方法，也就是EncryptOutputStream的close方法，而EncryptOutputStream的close方法继承自OutputStream，在OutputStream的close方法实现里面，是个空方法，什么都没有做。因此，这种实现方式没有flush流的数据，也就不会输出文件的内容，自然是一片空白了。


### 自己实现的I/O流的装饰器——第二版

要让我们写的装饰器跟其它Java中的装饰器一样用，最合理的方案就应该是：让我们的装饰器继承装饰器的父类，也就是FilterOutputStream类，然后使用父类提供的功能来协助完成想要装饰的功能。示例代码如下：

```java
/**
 * 实现简单的加密
 */
public class EncryptOutputStream2  extends FilterOutputStream{
    public EncryptOutputStream2(OutputStream os){
        //调用父类的构造方法
        super(os);
    }
    
    public void write(int a) throws IOException {
        //先统一向后移动两位
        a = a+2;
        //97是小写的a的码值
        if(a >= (97+26)){
            //如果大于，表示已经是y或者z了，减去26就回到a或者b了
            a = a-26;
        }
        //调用父类的方法
        super.write(a);
    }
}
```

## 22.3.2 装饰模式和AOP [demo6](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/decorator/demo6)

虽然装饰器模式对于共享的享元对象实例的管理要求，没有实例池对实例管理的要求那么高，但是也还是有很多自身的特点功能，比如：引用计数、垃圾清除等。所谓垃圾，就是在缓存中存在，但是不再需要被使用的缓存中的对象。

所谓引用计数，就是享元工厂能够记录每个享元被使用的次数；而垃圾清除，则是大多数缓存管理都有的功能，缓存不能只往里面放数据，在不需要这些数据的时候，应该把这些数据从缓存中清除，释放相应的内存空间，以节省资源。

在前面的示例中，共享的享元对象是很多人共享的，基本上可以一直存在于系统中，不用清除。但是垃圾清除是享元对象管理的一个很常见功能，还是通过示例给大家讲一下，看看如何实现这些常见的功能。

1. 实现引用计数的基本思路

    要实现引用计数，就在享元工厂里面定义一个Map，它的key值跟缓存享元对象的key是一样的，而value就是被引用的次数，这样当外部每次获取该享元的时候，就把对应的引用计数取出来加上1，然后再记录回去。

2. 实现垃圾回收的基本思路

    要实现垃圾回收就比较麻烦点，首先要能确定哪些是垃圾？其次是何时回收？还有由谁来回收？如何回收？解决了这些问题，也就能实现垃圾回收了。

    为了确定哪些是垃圾，一个简单的方案是这样的，定义一个缓存对象的配置对象，在这个对象中描述了缓存的开始时间和最长不被使用的时间，这个时候判断是垃圾的计算公式如下：当前的时间 - 缓存的开始时间 >= 最长不被使用的时间。当然，每次这个对象被使用的时候，就把那个缓存开始的时间更新为使用时的当前时间，也就是说如果一直有人用的话，这个对象是不会被判断为垃圾的。

    何时回收的问题，当然是判断出来是垃圾了就可以回收了。

    关键是谁来判断垃圾，还有谁来回收垃圾的问题。一个简单的方案是定义一个内部的线程，这个线程在享元工厂被创建的时候就启动运行。由这个线程每隔一定的时间来循环缓存中所有对象的缓存配置，看看是否是垃圾，如果是垃圾，那就可以启动回收了。

    怎么回收呢？这个比较简单，就是直接从缓存的map对象中删除掉相应的对象，让这些对象没有引用的地方，那么这些对象就可以等着被虚拟机的垃圾回收来回收掉了。

### 代码实现 [demo5](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/decorator/demo5)

（1）分析了这么多，还是看代码示例会比较清楚，先看缓存配置对象，示例代码如下：

```java
/**
 * 描述享元对象缓存的配置对象
 */
public class CacheConfModel{
    /**
     * 缓存开始计时的开始时间
     */
    private long beginTime;
    /**
     * 缓存对象存放的持续时间，其实是最长不被使用的时间
     */
    private double durableTime;
    /**
     * 缓存对象需要被永久存储，也就是不需要从缓存中删除
     */
    private boolean forever;
    public boolean isForever() {
        return forever;
    }
    public void setForever(boolean forever) {
        this.forever = forever;
    }
    public long getBeginTime() {
        return beginTime;
    }
    public void setBeginTime(long beginTime) {
        this.beginTime = beginTime;
    }
    public double getDurableTime() {
        return durableTime;
    }
    public void setDurableTime(double durableTime) {
        this.durableTime = durableTime;
    }
}
```

（2）对享元对象的管理的工作，是由享元工厂来完成的，因此上面的功能，也集中在享元工厂里面来实现，在上一个例子的基础之上，来实现这些功能，改进后的享元工厂相对而言稍复杂一点，大致有如下改变：

1. 添加一个Map，来缓存被共享对象的缓存配置的数据
2. 添加一个Map，来记录缓存对象被引用的次数
3. 为了测试方便，定义了一个常量来描述缓存的持续时间
4. 提供获取某个享元被使用的次数的方法
5. 在获取享元的对象里面，就要设置相应的引用计数和缓存设置了，示例采用的是内部默认设置一个缓存设置，其实也可以改造一下获取享元的方法，从外部传入缓存设置的数据
6. 提供一个清除缓存的线程，实现判断缓存数据是否已经是垃圾了，如果是，那就把它从缓存中清除掉

基本上重新实现了享元工厂，示例代码如下：

```java
/**
 * 享元工厂，通常实现成为单例
 * 加入实现垃圾回收和引用计数的功能
 */
public class decoratorFactory {
    private static decoratorFactory factory = new decoratorFactory();
    private decoratorFactory(){
        //启动清除缓存值的线程
        Thread t = new ClearCache();
        t.start();
    }
    public static decoratorFactory getInstance(){
        return factory;
    }
    /**
     * 缓存多个decorator对象
     */
    private Map<String,decorator> fsMap = new HashMap<String,decorator>();
    /**
     * 用来缓存被共享对象的缓存配置，key值和上面map的一样
     */
    private  Map<String,CacheConfModel> cacheConfMap = new HashMap<String,CacheConfModel>();
    /**
     * 用来记录缓存对象被引用的次数，key值和上面map的一样
     */
    private  Map<String,Integer> countMap = new HashMap<String,Integer>();
    /**
     * 默认保存6秒钟，主要为了测试方便，这个时间可以根据应用的要求设置，比如30分钟
     */
    private final  long DURABLE_TIME = 6*1000L; 
    
    /**
     * 获取某个享元被使用的次数
     * @param key 享元的key
     * @return 被使用的次数
     */
    public synchronized int getUseTimes(String key){
        Integer count = countMap.get(key);
        if(count==null){
            count = 0;
        }
        return count;
    }
    
    /**
     * 获取key对应的享元对象
     * @param key 获取享元对象的key
     * @return key对应的享元对象
     */
    public synchronized decorator getdecorator(String key) {
        decorator f = fsMap.get(key);
        //换一个更简单点的写法
        if(f==null){
            f = new Authorizationdecorator(key);
            fsMap.put(key,f);
            //同时设置引用计数
            countMap.put(key, 1);
            //同时设置缓存配置数据
            CacheConfModel cm = new CacheConfModel();
            cm.setBeginTime(System.currentTimeMillis());
            cm.setForever(false);
            cm.setDurableTime(DURABLE_TIME);
            
            cacheConfMap.put(key, cm);
        }else{
            //表示还在使用，那么应该重新设置缓存配置
            CacheConfModel cm = cacheConfMap.get(key);
            cm.setBeginTime(System.currentTimeMillis());
            //设置回去
            this.cacheConfMap.put(key, cm);
            //同时计数加1
            Integer count = countMap.get(key);
            count++;
            countMap.put(key, count);
        }
        return f;
    }
    
    /**
     * 删除key对应的享元对象，连带清除对应的缓存配置和引用次数的记录，不对外
     * @param key 要删除的享元对象的key
     */
    private synchronized void removedecorator(String key){
        this.fsMap.remove(key);
        this.cacheConfMap.remove(key);
        this.countMap.remove(key);
    }

    /**
     * 维护清除缓存的线程，内部使用
     */
    private  class ClearCache extends Thread{
        public void run(){
            while(true){
                Set<String> tempSet = new HashSet<String>();
                Set<String> set = cacheConfMap.keySet();
                for(String key : set){
                    CacheConfModel ccm = cacheConfMap.get(key);
                    //比较是否需要清除
                    if((System.currentTimeMillis() - ccm.getBeginTime()) >= ccm.getDurableTime()){
                        //可以清除，先记录下来
                        tempSet.add(key);
                    }
                }
                //真正清除
                for(String key : tempSet){
                    decoratorFactory.getInstance().removedecorator(key);                    
                }
                System.out.println("now thread="+fsMap.size()+",fsMap=="+fsMap.keySet());
                //休息1秒再重新判断
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

注意：getUseTimes、removedecorator和getdecorator这几个方法是加了同步的，原因是在多线程环境下使用它们，容易出现并发错误，比如一个线程在获取享元对象，而另一个线程在删除这个缓存对象。

（3）要想看出引用计数的效果来，SecurityMgr需要进行一点修改，至少不要再缓存数据了，要直接从享元工厂中获取数据，否则就没有办法准确引用计数了，大致改变如下：

1. 去掉了放置登录人员对应权限数据的缓存
2. 不需要实现登录功能，在这个示意程序里面，登录方法已经不用实现任何功能，因此直接去掉
3. 原来通过map获取值的地方，直接通过queryByUser获取就好了

示例代码如下：

```java
/**
 * 安全管理，实现成单例
 */
public class SecurityMgr {
    private static SecurityMgr securityMgr = new SecurityMgr();
    private SecurityMgr(){      
    }
    public static SecurityMgr getInstance(){
        return securityMgr;
    }
    
    /**
     * 判断某用户对某个安全实体是否拥有某权限
     * @param user 被检测权限的用户 
     * @param securityEntity 安全实体
     * @param permit 权限
     * @return true表示拥有相应权限，false表示没有相应权限
     */
    public boolean hasPermit(String user,String securityEntity,String permit){
        Collection<decorator> col = this.queryByUser(user);
        if(col==null || col.size()==0){
            System.out.println(user+"没有登录或是没有被分配任何权限");
            return false;
        }
        for(decorator fm : col){
            if(fm.match(securityEntity, permit)){
                return true;
            }
        }
        return false;
    }

    /**
     * 从数据库中获取某人所拥有的权限
     * @param user 需要获取所拥有的权限的人员
     * @return 某人所拥有的权限
     */
    private Collection<decorator> queryByUser(String user){
        Collection<decorator> col = new ArrayList<decorator>();
        
        for(String s : TestDB.colDB){
            String ss[] = s.split(",");
            if(ss[0].equals(user)){
                decorator fm = null;
                if(ss[3].equals("2")){
                    //表示是组合
                    fm = new UnsharedConcretedecorator();
                    //获取需要组合的数据
                    String tempSs[] = TestDB.mapDB.get(ss[1]);
                    for(String tempS : tempSs){
                        decorator tempFm = decoratorFactory.getInstance().getdecorator(tempS);
                        //把这个对象加入到组合对象中
                        fm.add(tempFm);
                    }
                }else{
                    fm = decoratorFactory.getInstance().getdecorator(ss[1]+","+ss[2]);
                }
                
                col.add(fm);
            }
        }
        return col;
    }   
}
```

（4）还是写个客户端来试试看，上面的享元工厂能否实现对享元对象的管理，尤其是对于垃圾回收和计数方面的功能，对于垃圾回收的功能不需要新加任何的测试代码，而对于引用计数的功能，需要写代码来调用才能看到效果，示例代码如下：

```java
public class Client {
    public static void main(String[] args) throws Exception{
        SecurityMgr mgr = SecurityMgr.getInstance();
        boolean f1 = mgr.hasPermit("张三","薪资数据","查看");
        boolean f2 = mgr.hasPermit("李四","薪资数据","查看");
        boolean f3 = mgr.hasPermit("李四","薪资数据","修改");

        //Thread.sleep(4000);
        for(int i=0;i<3;i++){
            mgr.hasPermit("张三"+i,"薪资数据","查看");
        }   
        
        //特别提醒：这里查看的引用次数，不是指测试使用的次数
        //指的是SecurityMgr的queryByUser方法通过享元工厂去获取享元对象的次数
        System.out.println("薪资数据,查看 被引用了"+decoratorFactory.getInstance().getUseTimes("薪资数据,查看")+"次");
        System.out.println("薪资数据,修改 被引用了"+decoratorFactory.getInstance().getUseTimes("薪资数据,修改")+"次");
        System.out.println("人员列表,查看 被引用了"+decoratorFactory.getInstance().getUseTimes("人员列表,查看")+"次");
    }
}
```

进行缓存的垃圾回收功能的是个线程在运行，所以你不终止该线程运行，程序会一直运行下去，运行部分结果如下：

```
薪资数据,查看 被引用了2次
薪资数据,修改 被引用了2次
人员列表,查看 被引用了6次
now thread=3,fsMap==[人员列表,查看, 薪资数据,修改, 薪资数据,查看]
now thread=3,fsMap==[人员列表,查看, 薪资数据,修改, 薪资数据,查看]
now thread=3,fsMap==[人员列表,查看, 薪资数据,修改, 薪资数据,查看]
now thread=3,fsMap==[人员列表,查看, 薪资数据,修改, 薪资数据,查看]
now thread=3,fsMap==[人员列表,查看, 薪资数据,修改, 薪资数据,查看]
now thread=3,fsMap==[人员列表,查看, 薪资数据,修改, 薪资数据,查看]
now thread=0,fsMap==[]
now thread=0,fsMap==[]
```

## 22.3.3  相关模式

* 装饰器模式与单例模式

    这两个模式可以组合使用。

    通常情况下，装饰器模式中的享元工厂可以实现成为单例。另外，享元工厂里面缓存的享元对象，都是单实例的，可以看成是单例模式的一种变形控制，在享元工厂里面来单例享元对象。

* 装饰器模式与组合模式

    这两个模式可以组合使用。

    在装饰器模式里面，存在不需要共享的享元实现，这些不需要共享的享元通常是对共享的享元对象的组合对象，也就是说，装饰器模式通常会和组合模式组合使用，来实现更复杂的对象层次结构。

* 装饰器模式与状态模式

    这两个模式可以组合使用。

    可以使用装饰器模式来共享状态模式中的状态对象，通常在状态模式中，会存在数量很大的、细粒度的状态对象，而且它们基本上都是可以重复使用的，都是用来处理某一个固定的状态的，它们需要的数据通常都是由上下文传入，也就是变化部分都分离出去了，所以可以用装饰器模式来实现这些状态对象。

* 装饰器模式与策略模式

    这两个模式可以组合使用。

    可以使用装饰器模式来实现策略模式中的策略对象，跟状态模式一样，在策略模式中也存在大量细粒度的策略对象，它们需要的数据同样是从上下文传入的，所以可以使用装饰器模式来实现这些策略对象