# 15.3 Java 设计模式系列教程（十二）组合模式之扩展

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[15.1 Java 设计模式系列教程（十二）组合模式之原理]()

[15.2 Java 设计模式系列教程（十二）组合模式之场景分析]()

[15.3 Java 设计模式系列教程（十二）组合模式之扩展]()

## 15.3.1 安全性和透明性

根据前面的讲述，在组合模式中，把组件对象分成了两种，一种是可以包含子组件的Composite对象，一种是不能包含其它组件对象的叶子对象。

Composite对象就像是一个容器，可以包含其它的Composite对象或叶子对象。当然有了容器，就要能对这个容器进行维护，需要向里面添加对象，并能够从容器里面获取对象，还有能从容器中删除对象，也就是说需要管理子组件对象。

这就产生了一个很重要的问题：到底在组合模式的类层次结构中，在哪一些类里面定义这些管理子组件的操作，到底应该在Component中声明这些操作，还是在Composite中声明这些操作？

这就需要仔细思考，在不同的实现中，进行安全性和透明性的权衡选择。

这里所说的安全性是指：从客户使用组合模式上看是否更安全。如果是安全的，那么不会有发生误操作的可能，能访问的方法都是被支持的功能。
这里所说的透明性是指：从客户使用组合模式上，是否需要区分到底是组合对象还是叶子对象。如果是透明的，那就是不再区分，对于客户而言，都是组件对象，具体的类型对于客户而言是透明的，是客户无需要关心的。

### 1：透明性的实现

如果把管理子组件的操作定义在Component中，那么客户端只需要面对Component，而无需关心具体的组件类型，这种实现方式就是透明性的实现。事实上，前面示例的实现方式都是这种实现方式。

但是透明性的实现是以安全性为代价的，因为在Component中定义的一些方法，对于叶子对象来说是没有意义的，比如：增加、删除子组件对象。而客户不知道这些区别，对客户是透明的，因此客户可能会对叶子对象调用这种增加或删除子组件的方法，这样的操作是不安全的。

组合模式的透明性实现，通常的方式是：在Component中声明管理子组件的操作，并在Component中为这些方法提供缺省的实现，如果是有子对象不支持的功能，缺省的实现可以是抛出一个例外，来表示不支持这个功能。

### 2：安全性的实现

如果把管理子组件的操作定义在Composite中，那么客户在使用叶子对象的时候，就不会发生使用添加子组件或是删除子组件的操作了，因为压根就没有这样的功能，这种实现方式是安全的。

但是这样一来，客户端在使用的时候，就必须区分到底使用的是Composite对象，还是叶子对象，不同对象的功能是不一样的。也就是说，这种实现方式，对客户而言就不是透明的了。

下面把用透明性方式实现的示例，改成用安全性的方式再实现一次，这样大家可以对比来看，可以更好的理解组合模式的透明性和安全性这两种实现方式。

先还是来看一下使用安全性方式实现示例的结构，如图15.6所示

![图15.6  使用组合模式的安全性实现方式来实现示例的结构示意图](img/15.6.jpg)

（1）首先看看Component的定义，跟透明性的实现相比，安全性的实现方式，Component里面不再定义管理和操作子组件的方法，把相应的方法都去掉。示例代码如下：

```java
/**
 * 抽象的组件对象
 */
public abstract class Component {
    /**
     * 输出组件自身的名称
     */
    public abstract void printStruct(String preStr);
}
```

（2）Composite对象和Leaf对象的实现都没有任何的变化，这里就不去赘述了

（3）接下来看看客户端的实现，客户端的变化主要是要区分Composite对象和Leaf对象，而原来是不区分的，都是Component对象。示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //定义所有的组合对象
        Composite root = new Composite("服装");
        Composite c1 = new Composite("男装");
        Composite c2 = new Composite("女装");

        //定义所有的叶子对象
        Component leaf1 = new Leaf("衬衣");
        Component leaf2 = new Leaf("夹克");
        Component leaf3 = new Leaf("裙子");
        Component leaf4 = new Leaf("套装");
        //按照树的结构来组合组合对象和叶子对象
        root.addChild(c1);
        root.addChild(c2);

        c1.addChild(leaf1);
        c1.addChild(leaf2);

        c2.addChild(leaf3);
        c2.addChild(leaf4);

        //调用根对象的输出功能来输出整棵树
        root.printStruct("");
    }
}
```

从上面的示例可以看出，从实现上，透明性和安全性的实现差别并不是很大。

### 3：两种实现方式的选择

对于组合模式而言，在安全性和透明性上，会更看重透明性，毕竟组合模式的功能就是要让用户对叶子对象和组合对象的使用具有一致性。

而且对于安全性的实现，需要区分是组合对象还是叶子对象，但是有的时候，你需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。

对于这种情况的处理方法是在Component里面定义一个getComposite的方法，用来判断是组合对象还是叶子对象，如果是组合对象，就返回组合对象，如果是叶子对象，就返回null，这样就可以先判断，然后再强制转换。

因此在使用组合模式的时候，建议多用透明性的实现方式，而少用安全性的实现方式。

## 15.3.2 父组件引用

## 15.3.3 安全性和透明性

## 15.3.4 安全性和透明性