# 22.1 Java 设计模式系列教程（二二）装饰器模式之原理

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%22Java%22%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[22.1 Java 设计模式系列教程（二二）装饰器模式之原理](22.1%22Java%22%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E7%90%86.md)

[22.2 Java 设计模式系列教程（二二）装饰器模式之场景分析](22.2%22Java%22%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90.md)

[22.3 Java 设计模式系列教程（二二）装饰器模式之扩展](22.3%22Java%22%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%89%A9%E5%B1%95.md)

> 动态地给一个对象添加一些额外的职责。就增加功能来说装饰模式比生成子类更为灵活。[decorator](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/decorator)

## 22.1.1 装饰器模式结构

![图22.1 装饰器模式结构示意图](img/22.1.jpg)

* `Component`：组件对象的接口，可以给这些对象动态的添加职责。

* `ConcreteComponent`：具体的组件对象，实现组件对象接口，通常就是被装饰器装饰的原始对象，也就是可以给这个对象添加职责。

* `Decorator`：所有装饰器的抽象父类，需要定义一个与组件接口一致的接口，并持有一个Component对象，其实就是持有一个被装饰的对象。

    注意这个被装饰的对象不一定是最原始的那个对象了，也可能是被其它装饰器装饰过后的对象，反正都是实现的同一个接口，也就是同一类型。


* `ConcreteDecorator`：实际的装饰器对象，实现具体要向被装饰对象添加的功能。

## 22.1.2 装饰器模式参考实现 [demo1](https://github.com/binarylei/demo/tree/master/demo-design/src/main/java/com/github/binarylei/design/decorator/demo1)

（1）先来看看组件对象的接口定义，示例代码如下：

```java
/**
 * 组件对象的接口，可以给这些对象动态的添加职责
 */
public abstract class Component {
    /**
     * 示例方法
     */
    public abstract void operation();
}
```

（2）定义了接口，那就看看具体组件实现对象示意吧，示例代码如下：

```java
/**
 * 具体实现组件对象接口的对象
 */
public class ConcreteComponent extends Component {

    public void operation() {
        //相应的功能处理
    }
}

```

（3）接下来看看抽象的装饰器对象，示例代码如下：

```java
/**
 * 装饰器接口，维持一个指向组件对象的接口对象，
 * 并定义一个与组件接口一致的接口
 */
public abstract class Decorator extends Component {
    /**
     * 持有组件对象
     */
    protected Component component;

    /**
     * 构造方法，传入组件对象
     * @param component 组件对象
     */
    public Decorator(Component component) {
        this.component = component;
    }

    public void operation() {
        //转发请求给组件对象，可以在转发前后执行一些附加动作
        component.operation();
    }
}
```

（4）该来看看具体的装饰器实现对象了，这里有两个示意对象，一个示意了添加状态，一个示意了添加职责。先看添加了状态的示意对象吧，示例代码如下：

```java
/**
 * 装饰器的具体实现对象，向组件对象添加职责
 */
public class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }
    /**
     * 添加的状态
     */
    private String addedState;
    
    public String getAddedState() {
        return addedState;
    }

    public void setAddedState(String addedState) {
        this.addedState = addedState;
    }

    public void operation() {
        //调用父类的方法，可以在调用前后执行一些附加动作
        //在这里进行处理的时候，可以使用添加的状态
        super.operation();
    }
}
```

## 22.1.3 进一步认识装饰器模式

#### 

## 22.1.4 总结

### 装饰器模式的本质

装饰器模式的本质： **分离与共享** 。

分离的是对象状态中变与不变的部分，共享的是对象中不变的部分。装饰器模式的关键之处就在于分离变与不变，把不变的部分作为享元对象的内部状态，而变化部分就作为外部状态，由外部来维护，这样享元对象就能够被共享，从而减少对象数量，并节省大量的内存空间。

理解了这个本质后，在使用装饰器模式的时候，就会去考虑，哪些状态需要分离？如何分离？分离后如何处理？哪些需要共享？如何管理共享的对象？外部如何使用共享的享元对象？是否需要不共享的对象？等等问题。

把这些问题都思考清楚，找到相应的解决方法，那么装饰器模式也就应用起来了，可能是标准的应用，也可能是变形的应用，但万变不离其宗。

### 何时选用装饰器模式

**建议在如下情况中，选用装饰器模式：**

1. 如果一个应用程序使用了大量的细粒度对象，可以使用装饰器模式来减少对象数量

2. 如果由于使用大量的对象，造成很大的存储开销，可以使用装饰器模式来减少对象数量，并节约内存

3. 如果对象的大多数状态都可以转变为外部状态，比如通过计算得到，或是从外部传入等，可以使用装饰器模式来实现内部状态和外部状态的分离

4. 如果不考虑对象的外部状态，可以用相对较少的共享对象取代很多组合对象，可以使用装饰器模式来共享对象，然后组合对象来使用这些共享对象

### 装饰器模式的优缺点

* 减少对象数量，节省内存空间

    可能有的朋友认为共享对象会浪费空间，但是如果这些对象频繁使用，那么其实是节省空间的。因为占用空间的大小等于每个对象实例占用的大小再乘以数量，对于享元对象来讲，基本上就只有一个实例，大大减少了享元对象的数量，并节省不少的内存空间。
    
    节省的空间取决于以下几个因素：因为共享而减少的实例数目、每个实例本身所占用的空间。假如每个对象实例占用2个字节，如果不共享数量是100个，而共享过后就只有一个了，那么节省的空间约等于：(100-1) X 2 字节。

* 维护共享对象，需要额外开销

    如同前面演示的享元工厂，在维护共享对象的时候，如果功能复杂，会有很多额外的开销，比如有一个线程来维护垃圾回收。