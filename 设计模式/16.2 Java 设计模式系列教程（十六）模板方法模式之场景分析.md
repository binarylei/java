# 16.2 Java 设计模式系列教程（十六）模板方法模式之场景分析

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[16.1 Java 设计模式系列教程（十六）模板方法模式之原理]()

[16.2 Java 设计模式系列教程（十六）模板方法模式之场景分析]()

[16.3 Java 设计模式系列教程（十六）模板方法模式之扩展]()

## 16.2.1 使用场景

几乎所有的应用系统，都需要系统登录控制的功能，有些系统甚至有多个登录控制的功能，比如：普通用户可以登录前台，进行相应的业务操作；而工作人员可以登录后台，进行相应的系统管理或业务处理。

现在有这么一个基于Web的企业级应用系统，需要实现这两种登录控制，直接使用不同的登录页面来区分它们，把基本的功能需求分别描述如下：

先看看普通用户登录前台的登录控制的功能：

1. 前台页面：用户能输入用户名和密码；提交登录请求，让系统去进行登录控制
2. 后台：从数据库获取登录人员的信息
3. 后台：判断从前台传递过来的登录数据，和数据库中已有的数据是否匹配
4. 前台Action：如果匹配就转向首页，如果不匹配就返回到登录页面，并显示错误提示信息

再来看看工作人员登录后台的登录控制功能：

1. 前台页面：用户能输入用户名和密码；提交登录请求，让系统去进行登录控制
2. 后台：从数据库获取登录人员的信息
3. 后台：把从前台传递过来的密码数据，使用相应的 **加密算法进行加密运算** ，得到加密后的密码数据
4. 后台：判断从前台传递过来的用户名和加密后的密码数据，和数据库中已有的数据是否匹配
5. 前台Action：如果匹配就转向首页，如果不匹配就返回到登录页面，并显示错误提示信息

说明：普通用户和工作人员在数据库里面是存储在不同表里面的；当然也是不同的模块来维护普通用户的数据和工作人员的数据；另外工作人员的密码是加密存放的。

## 16.2.2 不用模式的实现

### 代码实现 [demo2]()

由于普通用户登录和工作人员登录是不同的模块，有不同的页面，不同的逻辑处理，不同的数据存储，因此，在实现上完全当成两个独立的小模块去完成了。这里把它们的逻辑处理部分分别实现出来。

（1）先看普通用户登录的逻辑处理部分，示例代码如下：

```java
```

对应的LoginModel，示例代码如下：

```java
```

对应的UserModel，示例代码如下：

```java
```

（2）再看看工作人员登录的逻辑处理部分，示例代码如下：

```java
```

对应的LoginModel，示例代码如下：

```java
```

对应的WorkerModel，示例代码如下：

```java
```

运行一下，测试看看，是否能完成要求的功能。

### 问题出来了

看了上面的实现示例，是不是很简单。但是，仔细看看，总会觉得有点问题，两种登录的实现太相似了，现在是完全分开，当作两个独立的模块来实现的，如果今后要扩展功能，比如要添加“控制同一个编号同时只能登录一次”的功能，那么两个模块都需要修改，是很麻烦的。而且，现在的实现中，也有很多相似的地方，显得很重复。另外，具体的实现和判断的步骤混合在一起，不利于今后变换功能，比如要变换加密算法等。

总之，上面的实现，有两个很明显的问题：一是重复或相似代码太多；二是扩展起来很不方便。

那么该怎么解决呢？该如何实现才能让系统既灵活又能简洁的实现需求功能呢？

## 16.2.3 解决方案

### 应用模板方法模式的解决思路

要使用模板方法模式来实现前面的示例，按照模板方法模式的定义和结构，需要定义出一个抽象的父类，在这个父类里面定义模板方法，这个模板方法应该实现进行登录控制的整体的算法步骤。当然公共的功能，就放到这个父类去实现，而这个父类无法决定的功能，就延迟到子类去实现。

这样一来，两种登录控制就做为这个父类的子类，分别实现自己需要的功能。此时系统的结构如图16.2所示：

![图16.2  使用模板方法模式实现示例的结构示意图](img/16.2.jpg)

### 代码实现 [demo3]()

（1）为了把原来的两种登录控制统一起来，首先需要把封装登录控制所需要的数据模型统一起来，不再区分是用户编号还是工作人员编号，而是统一称为登录人员的编号，还有把其它用不上的数据去掉，这样就直接使用一个数据模型就可以了。当然，如果各个子类实现需要其它的数据，还可以自行扩展。示例代码如下：

```java
/**
 * 封装进行登录控制所需要的数据
 */
public class LoginModel {
    /**
     * 登录人员的编号，通用的，可能是用户编号，也可能是工作人员编号
     */
    private String loginId;
    /**
     * 登录的密码
     */
    private String pwd;
    public String getLoginId() {
        return loginId;
    }
    public void setLoginId(String loginId) {
        this.loginId = loginId;
    }
    public String getPwd() {
        return pwd;
    }
    public void setPwd(String pwd) {
        this.pwd = pwd;
    }
}
```

（2）接下来定义公共的登录控制算法骨架，示例代码如下：

```java
/**
 *  登录控制的模板
 */
public abstract class LoginTemplate {
    /**
     * 判断登录数据是否正确，也就是是否能登录成功
     * @param lm 封装登录数据的Model
     * @return true表示登录成功，false表示登录失败
     */
    public final boolean login(LoginModel lm){
        //1：根据登录人员的编号去获取相应的数据
        LoginModel dbLm = this.findLoginUser(lm.getLoginId());
        if(dbLm!=null){
            //2：对密码进行加密
            String encryptPwd = this.encryptPwd(lm.getPwd());
            //把加密后的密码设置回到登录数据模型里面
            lm.setPwd(encryptPwd);
            //3：判断是否匹配
            return this.match(lm, dbLm);
        }
        return false;
    }

    /**
     * 根据登录编号来查找和获取存储中相应的数据
     * @param loginId 登录编号
     * @return 登录编号在存储中相对应的数据
     */
    public abstract LoginModel findLoginUser(String loginId);

    /**
     * 对密码数据进行加密
     * @param pwd 密码数据
     * @return 加密后的密码数据
     */
    public String encryptPwd(String pwd){
        return pwd;
    }

    /**
     * 判断用户填写的登录数据和存储中对应的数据是否匹配得上
     * @param lm 用户填写的登录数据
     * @param dbLm 在存储中对应的数据
     * @return true表示匹配成功，false表示匹配失败
     */
    public boolean match(LoginModel lm,LoginModel dbLm){
        if(lm.getLoginId().equals(dbLm.getLoginId())
                && lm.getPwd().equals(dbLm.getPwd())){
            return true;
        }
        return false;
    }
}
```

（3）实现新的普通用户登录控制的逻辑处理，示例代码如下：

```java
/**
 * 普通用户登录控制的逻辑处理
 */
public class NormalLogin extends LoginTemplate{
    public LoginModel findLoginUser(String loginId) {
        // 这里省略具体的处理，仅做示意，返回一个有默认数据的对象
        LoginModel lm = new LoginModel();
        lm.setLoginId(loginId);
        lm.setPwd("testpwd");
        return lm;
    }
}
```

（4）实现新的工作人员登录控制的逻辑处理，示例代码如下：

```java
/**
 * 工作人员登录控制的逻辑处理
 */
public class WorkerLogin extends LoginTemplate{

    public LoginModel findLoginUser(String loginId) {
        // 这里省略具体的处理，仅做示意，返回一个有默认数据的对象
        LoginModel lm = new LoginModel();
        lm.setLoginId(loginId);
        lm.setPwd("workerpwd");
        return lm;
    }

    public String encryptPwd(String pwd){
        //覆盖父类的方法，提供真正的加密实现
        //这里对密码进行加密，比如使用：MD5、3DES等等，省略了
        System.out.println("使用MD5进行密码加密");
        return pwd;
    }
}
```

通过上面的示例，可以看出来，把原来的实现改成使用模板方法模式来实现，也并不困难，写个客户端测试一下，以便更好的体会，示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //准备登录人的信息
        LoginModel lm = new LoginModel();
        lm.setLoginId("admin");
        lm.setPwd("workerpwd");

        //准备用来进行判断的对象
        LoginTemplate lt = new WorkerLogin();
        LoginTemplate lt2 = new NormalLogin();
        //进行登录测试
        boolean flag = lt.login(lm);
        System.out.println("可以登录工作平台="+flag);

        boolean flag2 = lt2.login(lm);
        System.out.println("可以进行普通人员登录="+flag2);
    }
}
```

运行结果示例如下：

```
使用MD5进行密码加密
可以登录工作平台=true
可以进行普通人员登录=false
```

当然，你可以使用不同的测试数据来测试这个示例。