# 16.3 Java 设计模式系列教程（十六）模板方法模式之扩展

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[16.1 Java 设计模式系列教程（十六）模板方法模式之原理]()

[16.2 Java 设计模式系列教程（十六）模板方法模式之场景分析]()

[16.3 Java 设计模式系列教程（十六）模板方法模式之扩展]()

## 16.3.1 扩展登录控制

如果需要加入新的功能，也需要新的数据。比如：现在对于普通人员登录，要实现一个加强版，要求登录人员除了编号和密码外，还需要提供注册时留下的验证问题和验证答案，验证问题和验证答案是记录在数据库中的，不是验证码，一般Web开发中登录使用的验证码会放到session中，这里不去讨论它。

假如现在就要进行如此的扩展，应该怎么实现呢？由于需要一些其它的数据，那么就需要扩展LoginModel，加入自己需要的数据；同时可能需要覆盖由父类提供的一些公共的方法，来实现新的功能。

还是看看代码示例吧，会比较清楚。

首先呢，需要扩展LoginModel，把具体功能需要的数据封装起来，只是增加父类没有的数据就可以了，示例代码如下：

```java
/**
 * 封装进行登录控制所需要的数据，在公共数据的基础上，
 * 添加具体模块需要的数据
 */
public class NormalLoginModel extends LoginModel{
    /**
     * 密码验证问题
     */
    private String question;

    /**
     * 密码验证答案
     */
    private String answer;
    public String getQuestion() {
        return question;
    }
    public void setQuestion(String question) {
        this.question = question;
    }
    public String getAnswer() {
        return answer;
    }
    public void setAnswer(String answer) {
        this.answer = answer;
    }
}
```

其次呢，就是提供新的登录模块控制实现，示例代码如下：

```java
/**
 * 普通用户登录控制加强版的逻辑处理
 */
public class NormalLogin2 extends LoginTemplate{
    public LoginModel findLoginUser(String loginId) {
        // 这里省略具体的处理，仅做示意，返回一个有默认数据的对象
        //注意一点：这里使用的是自己需要的数据模型了
        NormalLoginModel dbLm = new NormalLoginModel();
        dbLm.setLoginId(loginId);
        dbLm.setPwd("testpwd");
        dbLm.setQuestion("testQuestion");
        dbLm.setAnswer("testAnswer");

        return dbLm;
    }

    public boolean match(LoginModel lm, LoginModel dbLm){
        //这个方法需要覆盖，因为现在进行登录控制的时候，
        //需要检测4个值是否正确，而不仅仅是缺省的2个

        //先调用父类实现好的，检测编号和密码是否正确
        boolean f1 = super.match(lm, dbLm);
        if(f1){
            //如果编号和密码正确，继续检查问题和答案是否正确

            //先把数据转换成自己需要的数据
            NormalLoginModel nlm = (NormalLoginModel)lm;
            NormalLoginModel dbNlm = (NormalLoginModel)dbLm;
            //检查问题和答案是否正确
            if(dbNlm.getQuestion().equals(nlm.getQuestion())
                    && dbNlm.getAnswer().equals(nlm.getAnswer())){
                return true;
            }
        }
        return false;
    }
}
```

看看这个时候的测试，示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //准备登录人的信息
        NormalLoginModel nlm = new NormalLoginModel();
        nlm.setLoginId("testUser");
        nlm.setPwd("testpwd");
        nlm.setQuestion("testQuestion");
        nlm.setAnswer("testAnswer");
        //准备用来进行判断的对象
        LoginTemplate lt3 = new NormalLogin2();
        //进行登录测试
        boolean flag3 = lt3.login(nlm);
        System.out.println("可以进行普通人员加强版登录="+flag3);
    }
}
```

运行看看，能实现功能吗？好好测试体会一下，看看是如何扩展功能的。

## 16.3.2 模板的写法

在实现模板的时候，到底哪些方法实现在模板上呢？模板能不能全部实现了，也就是模板不提供抽象方法呢？当然，就算没有抽象方法，模板一样可以定义成为抽象类。

通常在模板里面包含如下操作类型：

1. **模板方法** ：就是定义算法骨架的方法 。

2. **具体的操作** ：在模板中直接实现某些步骤的方法，通常这些步骤的实现算法是固定的，而且是不怎么变化的，因此就可以当作公共功能实现在模板里面。如果不需提供给子类访问这些方法的话，还可以是private的。这样一来，子类的实现就相对简单些。如果是子类需要访问，可以把这些方法定义为protected final的，因为通常情况下，这些实现不能够被子类覆盖和改变了。

3. **具体的AbstractClass操作** ：在模板中实现某些公共功能，可以提供给子类使用，一般不是具体的算法步骤的实现，只是一些辅助的公共功能。

4. **原语操作** ：就是在模板中定义的抽象操作，通常是模板方法需要调用的操作，是必需的操作，而且在父类中还没有办法确定下来如何实现，需要子类来真正实现的方法。

5. **钩子操作** ：在模板中定义，并提供默认实现的操作。这些方法通常被视为可扩展的点，但不是必须的，子类可以有选择的覆盖这些方法，以提供新的实现来扩展功能。比如：模板方法中定义了5步操作，但是根据需要，某一种具体的实现只需要其中的1、2、3这几个步骤，因此它就只需要覆盖实现1、2、3这几个步骤对应的方法。那么4和5步骤对应的方法怎么办呢，由于有默认实现，那就不用管了。也就是说钩子操作是可以被扩展的点，但不是必须的。

6. **Factory Method** ：在模板方法中，如果需要得到某些对象实例的话，可以考虑通过工厂方法模式来获取，把具体的构建对象的实现延迟到子类中去。

总结起来，一个较为完整的模板定义示例，示例代码如下：

```java
/**
 * 一个较为完整的模版定义示例
 */
public abstract class AbstractTemplate {
    /**
     * 模板方法，定义算法骨架
     */
    public final void templateMethod(){
        //第一步
        this.operation1();
        //第二步
        this.operation2();
        //第三步
        this.doPrimitiveOperation1();
        //第四步
        this.doPrimitiveOperation2();
        //第五步
        this.hookOperation1();
    }

    /**
     * 具体操作1，算法中的步骤，固定实现，而且子类不需要访问
     */
    private void operation1(){
        //在这里具体的实现
    }

    /**
     * 具体操作2，算法中的步骤，固定实现，子类可能需要访问，
     * 当然也可以定义成public的，不可以被覆盖，因此是final的
     */
    protected final void operation2(){
        //在这里具体的实现
    }

    /**
     * 具体的AbstractClass操作，子类的公共功能，
     * 但通常不是具体的算法步骤
     */
    protected void commonOperation(){
        //在这里具体的实现
    }

    /**
     * 原语操作1，算法中的必要步骤，父类无法确定如何真正实现，需要子类来实现
     */
    protected abstract void doPrimitiveOperation1();

    /**
     * 原语操作2，算法中的必要步骤，父类无法确定如何真正实现，需要子类来实现
     */
    protected abstract void doPrimitiveOperation2();

    /**
     * 钩子操作，算法中的步骤，不一定需要，提供缺省实现
     * 由子类选择并具体实现
     */
    protected void hookOperation1(){
        //在这里提供缺省的实现
    }

    /**
     * 工厂方法，创建某个对象，这里用Object代替了，在算法实现中可能需要
     * @return 创建的某个算法实现需要的对象
     */
    protected abstract Object createOneObject();
}
```

## 16.3.3 Java回调与模板方法模式 [demo6]()

模板方法模式的一个目的，就在于让其它类来扩展或具体实现在模板中固定的算法骨架中的某些算法步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。

其实在Java开发中，还有另外一个方法可以实现同样的功能或是效果，那就是——Java回调技术，通过回调在接口中定义的方法，调用到具体的实现类中的方法，其本质同样是利用Java的动态绑定技术，在这种实现中，可以不把实现类写成单独的类，而是使用匿名内部类来实现回调方法。

应用Java回调来实现模板方法模式，在实际开发中使用得也非常多，就算是模板方法模式的一种变形实现吧。

还是来示例一下，这样会更清楚。为了大家好对比理解，把前面用标准模板方法模式实现的例子，采用Java回调来实现一下。

（1）先定义一个模板方法需要的回调接口

在这个接口中需要把所有可以被扩展的方法都要定义出来。实现的时候，可以不扩展，直接转调模板中的默认实现，但是不能不定义出来，因为是接口，不定义出来，对于想要扩展这些功能的地方就没有办法了。示例代码如下：

```java
/**
 * 登录控制的模板方法需要的回调接口，
 * 需要尽可能的把所有需要的接口方法都定义出来,
 * 或者说是所有可以被扩展的方法都需要被定义出来
 */
public interface LoginCallback {
    /**
     * 根据登录编号来查找和获取存储中相应的数据
     * @param loginId 登录编号
     * @return 登录编号在存储中相对应的数据
     */
    public LoginModel findLoginUser(String loginId);

    /**
     * 对密码数据进行加密
     * @param pwd 密码数据
     * @param template LoginTemplate对象，通过它来调用在
     *              LoginTemplate中定义的公共方法或缺省实现
     * @return 加密后的密码数据
     */
    public String encryptPwd(String pwd,LoginTemplate template);

    /**
     * 判断用户填写的登录数据和存储中对应的数据是否匹配得上
     * @param lm 用户填写的登录数据
     * @param dbLm 在存储中对应的数据
     * @param template LoginTemplate对象，通过它来调用在
     *              LoginTemplate中定义的公共方法或缺省实现
     * @return true表示匹配成功，false表示匹配失败
     */
    public boolean match(LoginModel lm,LoginModel dbLm,LoginTemplate template);
}
```

（2）这里使用的LoginModel跟以前没有任何变化，就不去赘述了。

（3）该来定义登录控制的模板了，它的变化相对较多，大致有以下一些：

1. 不再是抽象的类了，所有的抽象方法都去掉了
2. 对模板方法就是login的那个方法，添加一个参数，传入回调接口
3. 在模板方法实现中，除了在模板中固定的实现外，所有可以被扩展的方法，都应该通过回调接口进行调用

示例代码如下：

```java
/**
 *  登录控制的模板
 */
public class LoginTemplate {
    /**
     * 判断登录数据是否正确，也就是是否能登录成功
     * @param lm 封装登录数据的Model
     * @param callback LoginCallback对象
     * @return true表示登录成功，false表示登录失败
     */
    public final boolean login(LoginModel lm, LoginCallback callback){
        //1：根据登录人员的编号去获取相应的数据
        LoginModel dbLm = callback.findLoginUser(lm.getLoginId());
        if(dbLm!=null){
            //2：对密码进行加密
            String encryptPwd = callback.encryptPwd(lm.getPwd(),this);
            //把加密后的密码设置回到登录数据模型里面
            lm.setPwd(encryptPwd);
            //3：判断是否匹配
            return callback.match(lm, dbLm,this);
        }
        return false;
    }

    /**
     * 对密码数据进行加密
     * @param pwd 密码数据
     * @return 加密后的密码数据
     */
    public String encryptPwd(String pwd){
        return pwd;
    }

    /**
     * 判断用户填写的登录数据和存储中对应的数据是否匹配得上
     * @param lm 用户填写的登录数据
     * @param dbLm 在存储中对应的数据
     * @return true表示匹配成功，false表示匹配失败
     */
    public boolean match(LoginModel lm,LoginModel dbLm){
        if(lm.getLoginId().equals(dbLm.getLoginId())
                && lm.getPwd().equals(dbLm.getPwd())){
            return true;
        }
        return false;
    }
}
```

（4）由于是直接在调用的地方传入回调的实现，通常可以通过匿名内部类的方式来实现回调接口，当然实现成为具体类也是可以的。如果采用匿名内部类的方式来使用模板，那么就不需要原来的NormalLogin和WorkerLogin了。

（5）写个客户端来测试看看，客户端需要使用匿名内部类来实现回调接口，并实现其中想要扩展的方法，示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //准备登录人的信息
        LoginModel lm = new LoginModel();
        lm.setLoginId("admin");
        lm.setPwd("workerpwd");
        //准备用来进行判断的对象
        LoginTemplate lt = new LoginTemplate();

        //进行登录测试，先测试普通人员登录
        boolean flag = lt.login(lm, new LoginCallback(){
            public String encryptPwd(String pwd, LoginTemplate template) {
                //自己不需要，直接转调模板中的默认实现
                return template.encryptPwd(pwd);
            }
            public LoginModel findLoginUser(String loginId) {
                // 这里省略具体的处理，仅做示意，返回一个有默认数据的对象
                LoginModel lm = new LoginModel();
                lm.setLoginId(loginId);
                lm.setPwd("testpwd");
                return lm;
            }
            public boolean match(LoginModel lm, LoginModel dbLm,
                                 LoginTemplate template) {
                //自己不需要覆盖，直接转调模板中的默认实现
                return template.match(lm, dbLm);
            }
        });
        System.out.println("可以进行普通人员登录="+flag);

        //测试工作人员登录
        boolean flag2 = lt.login(lm,new LoginCallback(){
            public String encryptPwd(String pwd, LoginTemplate template) {
                //覆盖父类的方法，提供真正的加密实现
                //这里对密码进行加密，比如使用：MD5、3DES等等，省略了
                System.out.println("使用MD5进行密码加密");
                return pwd;
            }
            public LoginModel findLoginUser(String loginId) {
                // 这里省略具体的处理，仅做示意，返回一个有默认数据的对象
                LoginModel lm = new LoginModel();
                lm.setLoginId(loginId);
                lm.setPwd("workerpwd");
                return lm;
            }
            public boolean match(LoginModel lm, LoginModel dbLm,
                                 LoginTemplate template) {
                //自己不需要覆盖，直接转调模板中的默认实现
                return template.match(lm, dbLm);
            }

        });
        System.out.println("可以登录工作平台="+flag2);
    }
}
```

 运行一下，看看效果是不是跟前面采用继承的方式实现的结果是一样的，然后好好比较一下这两种实现方式。

（6）简单小结一下，对于模板方法模式的这两种实现方式：

**使用继承的方式，抽象方法和具体实现的关系，是在编译期间静态决定的，是类级的关系；使用Java回调，这个关系是在运行期间动态决定的，是对象级的关系。**

相对而言，使用回调机制会更灵活，因为Java是单继承的，如果使用继承的方式，对于子类而言，今后就不能继承其它对象了，而使用回调，是基于接口的。
    
从另一方面说，回调机制是通过委托的方式来组合功能，它的耦合强度要比继承低一些，这会给我们更多的灵活性。比如某些模板实现的方法，在回调实现的时候可以不调用模板中的方法，而是调用其它实现中的某些功能，也就是说功能不再局限在模板和回调实现上了，可以更灵活组织功能。

相对而言，使用继承方式会更简单点，因为父类提供了实现的方法，子类如果不想扩展，那就不用管。如果使用回调机制，回调的接口需要把所有可能被扩展的方法都定义进去，这就导致实现的时候，不管你要不要扩展，你都要实现这个方法，哪怕你什么都不做，只是转调模板中已有的实现，都要写出来。

事实上，在前面讲命令模式的时候也提到了Java回调，还通过退化命令模式来实现了Java回调的功能，所以也有这样的说法：命令模式可以作为模板方法模式的一种替代实现，那就是因为可以使用Java回调来实现模板方法模式。


## 16.3.4 典型应用：排序 [demo7]()

 模板方法模式的一个非常典型的应用，就是实现排序的功能。至于有些朋友认为排序是策略模式的体现，这很值得商榷。先来看看在Java中排序功能的实现，然后再来说明为什么排序的实现主要体现了模板方法模式，而非策略模式。

在java.util包中，有一个Collections类，它里面实现了对列表排序的功能，它提供了一个静态的sort方法，接受一个列表和一个Comparator接口的实例，这个方法实现的大致步骤是：

1. 先把列表转换成为对象数组
2. 通过Arrays的sort方法来对数组进行排序，传入Comparator接口的实例
3. 然后再把排好序的数组的数据设置回到原来的列表对象中去

这其中的算法步骤是固定的，也就是算法骨架是固定的了，只是其中具体比较数据大小的步骤，需要由外部来提供，也就是传入的Comparator接口的实例，就是用来实现数据比较的，在算法内部会通过这个接口来回调具体的实现。

如果Comparator接口的compare()方法返回一个小于0的数，表示被比较的两个对象中，前面的对象小于后面的对象；如果返回一个等于0的数，表示被比较的两个对象相等；如果返回一个大于0的数，表示被比较的两个对象中，前面的对象大于后面的对象。

下面一起看看使用Collections来对列表排序的例子，假如现在要实现对一个拥有多个用户数据模型的列表进行排序。

（1）当然，先要定义出封装用户数据的对象模型来，示例代码如下：

```java
/**
 * 用户数据模型
 */
public class UserModel {
    private String userId,name;
    private int age;
    public UserModel(String userId,String name,int age) {
        this.userId = userId;
        this.name = name;
        this.age = age;
    }
    public String getUserId() {
        return userId;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }
    @Override
    public String toString(){
        return "userId="+userId+",name="+name+",age="+age;
    }
}
```

（2）直接使用Collections来排序，写个客户端来测试一下，示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //准备要测试的数据
        UserModel um1 = new UserModel("u1","user1",23);
        UserModel um2 = new UserModel("u2","user2",22);
        UserModel um3 = new UserModel("u3","user3",21);
        UserModel um4 = new UserModel("u4","user4",24);
        //添加到列表中
        List<UserModel> list = new ArrayList<UserModel>();
        list.add(um1);
        list.add(um2);
        list.add(um3);
        list.add(um4);

        System.out.println("排序前---------------------〉");
        printList(list);
        //实现比较器，也可以单独用一个类来实现
        Comparator c = new Comparator(){
            public int compare(Object obj1, Object obj2) {
                //假如实现按照年龄升序排序
                UserModel tempUm1 = (UserModel)obj1;
                UserModel tempUm2 = (UserModel)obj2;
                if(tempUm1.getAge() > tempUm2.getAge()){
                    return 1;
                }else if(tempUm1.getAge() == tempUm2.getAge()){
                    return 0;
                }else if(tempUm1.getAge() < tempUm2.getAge()){
                    return -1;
                }
                return 0;
            }};

        //排序
        Collections.sort(list, c);

        System.out.println("排序后---------------------〉");
        printList(list);

    }
    private static void printList(List<UserModel> list){
        for(UserModel um : list){
            System.out.println(um);
        }
    }
}
```

运行一下，结果如下所示：

```
排序前---------------------〉
userId=u1,name=user1,age=23
userId=u2,name=user2,age=22
userId=u3,name=user3,age=21
userId=u4,name=user4,age=24
排序后---------------------〉
userId=u3,name=user3,age=21
userId=u2,name=user2,age=22
userId=u1,name=user1,age=23
userId=u4,name=user4,age=24
```

## 16.3.5  相关模式

* 模板方法模式和工厂方法模式
    
    这两个模式可以配合使用。模板方法模式可以通过工厂方法来获取需要调用的对象。

* 模板方法模式和策略模式

    这两个模式的功能有些相似，但是是有区别的。

    从表面上看，两个模式都能实现算法的封装，但是模板方法封装的是算法的骨架，这个算法骨架是不变的，变化的是算法中某些步骤的具体实现；而策略模式是把某个步骤的具体实现算法封装起来，所有封装的算法对象是等价的，可以相互替换。

    因此，可以在模板方法中使用策略模式，就是把那些变化的算法步骤通过使用策略模式来实现，但是具体选取哪个策略还是要由外部来确定，而整体的算法步骤，也就是算法骨架就由模板方法来定义了。

