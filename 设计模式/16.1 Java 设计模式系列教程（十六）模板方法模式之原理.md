# 16.1 Java 设计模式系列教程（十六）模板方法模式之原理

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[16.1 Java 设计模式系列教程（十六）模板方法模式之原理]()

[16.2 Java 设计模式系列教程（十六）模板方法模式之场景分析]()

[16.3 Java 设计模式系列教程（十六）模板方法模式之扩展]()

> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个得法的结构即可重定义该算法的某些特定步骤。[demo]()

## 16.1.1 模板方法模式结构

![16.1模板方法模式结构示意图](img/16.1.jpg)

* `AbstractClass`：抽象类。用来定义算法骨架和原语操作，具体的子类通过重定义这些原语操作来实现一个算法的各个步骤。在这个类里面，还可以提供算法中通用的实现。

* `ConcreteClass`：具体实现类。用来实现算法骨架中的某些步骤，完成跟特定子类相关的功能。

## 16.1.2 模板方法模式参考实现 [demo1]()

（1）先来看看AbstractClass的写法，示例代码如下：

```java
/**
 * 定义模板方法、原语操作等的抽象类
 */
public abstract class AbstractClass {
    /**
     * 原语操作1，所谓原语操作就是抽象的操作，必须要由子类提供实现
     */
    public abstract void doPrimitiveOperation1();
    /**
     * 原语操作2
     */
    public abstract void doPrimitiveOperation2();
    /**
     * 模板方法，定义算法骨架
     */
    public final void templateMethod() {
        doPrimitiveOperation1();
        doPrimitiveOperation2();
    }
}
```

（2）再看看具体实现类的写法，示例代码如下：

```java
/**
 * 具体实现类，实现原语操作
 */
public class ConcreteClass extends AbstractClass {
    public void doPrimitiveOperation1() {
        //具体的实现
    }
    public void doPrimitiveOperation2() {
        //具体的实现
    }
}
```

## 16.1.3 进一步认识模板方法模式

#### （1）模式的功能

模板方法的功能在于固定算法骨架，而让具体算法实现可扩展。

这在实际应用中非常广泛，尤其是在设计框架级功能的时候非常有用。框架定义好了算法的步骤，在合适的点让开发人员进行扩展，实现具体的算法。比如在DAO实现中，设计通用的增删改查功能，这个后面会给大家示例。

模板方法还额外提供了一个好处，就是可以控制子类的扩展。因为在父类里面定义好了算法的步骤，只是在某几个固定的点才会调用到被子类实现的方法，因此也就只允许在这几个点来扩展功能，这些个可以被子类覆盖以扩展功能的方法通常被称为“钩子”方法，后面也会给大家示例。

#### （2）为何不是接口

有的朋友可能会问一个问题，不是说在Java中应该尽量面向接口编程吗，为何模板方法的模板是采用的抽象方法呢？

要回答这个问题，要首先搞清楚抽象类和接口的关系：

接口是一种特殊的抽象类，所有接口中的属性自动是常量，也就是public final static的，而所有接口中的方法必须是抽象的

抽象类，简单点说是用abstract修饰的类。这里要特别注意的是抽象类和抽象方法的关系，记住两句话：抽象类不一定包含抽象方法；有抽象方法的类一定是抽象类

抽象类和接口相比较，最大的特点就在于抽象类里面是可以有具体的实现方法的，而接口中所有的方法都是没有具体的实现的。

因此，虽然Java编程中倡导大家“面向接口编程”，并不是说就不再使用抽象类了，那么什么时候使用抽象类呢？

通常在“既要约束子类的行为，又要为子类提供公共功能”的时候使用抽象类。

按照这个原则来思考模板方法模式的实现，模板方法模式需要固定定义算法的骨架，这个骨架应该只有一份，算是一个公共的行为，但是里面具体的步骤的实现又可能是各不相同的，恰好符合选择抽象类的原则。

把模板实现成为抽象类，为所有的子类提供了公共的功能，就是定义了具体的算法骨架；同时在模板里面把需要由子类扩展的具体步骤的算法定义成为抽象方法，要求子类去实现这些方法，这就约束了子类的行为。

因此综合考虑，用抽象类来实现模板是一个很好的选择。

#### （3）变与不变

程序设计的一个很重要的思考点就是“变与不变”，也就是分析程序中哪些功能是可变的，哪些功能是不变的，然后把不变的部分抽象出来，进行公共的实现，把变化的部分分离出去，用接口来封装隔离，或者是用抽象类来约束子类行为。

模板方法模式很好的体现了这一点。模板类实现的就是不变的方法和算法的骨架，而需要变化的地方，都通过抽象方法，把具体实现延迟到子类去了，而且还通过父类的定义来约束了子类的行为，从而使系统能有更好的复用性和扩展性。

#### （4）好莱坞法则

什么是好莱坞法则呢？简单点说，就是“不要找我们，我们会联系你”。

模板方法模式很好的体现了这一点，做为父类的模板会在需要的时候，调用子类相应的方法，也就是由父类来找子类，而不是让子类来找父类。

这其实也是一种反向的控制结构，按照通常的思路，是子类找父类才对，也就是应该是子类来调用父类的方法，因为父类根本就不知道子类，而子类是知道父类的，但是在模板方法模式里面，是父类来找子类，所以是一种反向的控制结构。

那么，在Java里面能实现这样功能的理论依据在哪里呢？

理论依据就在于Java的动态绑定采用的是“后期绑定”技术，对于出现子类覆盖父类方法的情况，在编译时是看数据类型，运行时看实际的对象类型（new操作符后跟的构造方法是哪个类的），一句话：new谁就调用谁的方法。

因此在使用模板方法模式的时候，虽然用的数据类型是模板类型，但是在创建类实例的时候是创建的具体的子类的实例，因此调用的时候，会被动态绑定到子类的方法上去，从而实现反向控制。其实在写父类的时候，它调用的方法是父类自己的抽象方法，只是在运行的时候被动态绑定到了子类的方法上。

## 16.1.4 总结

### 模板方法模式的本质

模板方法模式的本质： **固定算法骨架。**

模板方法模式主要是通过制定模板，把算法步骤固定下来，至于谁来实现，模板可以自己提供实现，也可以由子类去实现，还可以通过回调机制让其它类来实现。

通过固定算法骨架，来约束子类的行为，并在特定的扩展点，来让子类进行功能扩展，从而让程序既有很好的复用性，又有较好的扩展性。

### 对设计原则的体现

模板方法很好的体现了开闭原则和里氏替换原则。

首先从设计上，先分离变与不变，然后把不变的部分抽取出来，定义到父类里面，比如算法骨架，比如一些公共的、固定的实现等等。这些不变的部分被封闭起来，尽量不去修改它了，要扩展新的功能，那就使用子类来扩展，通过子类来实现可变化的步骤，对于这种新增功能的做法是开放的。

其次，能够实现统一的算法骨架，通过切换不同的具体实现来切换不同的功能，一个根本原因就是里氏替换原则，遵循这个原则，保证所有的子类实现的是同一个算法模板，并能在使用模板的地方，根据需要，切换不同的具体实现。

### 何时选用模板方法模式

**建议在如下情况中，选用模板方法模式：**

1. 需要固定定义算法骨架，实现一个算法的不变的部分，并把可变的行为留给子类来实现的情况
2. 各个子类中具有公共行为，应该抽取出来，集中在一个公共类中去实现，从而避免代码重复
3. 需要控制子类扩展的情况。模板方法模式会在特定的点来调用子类的方法，这样只允许在这些点进行扩展

### 模板方法模式的优缺点

* 实现代码复用
    
    模板方法模式是一种实现代码复用的很好的手段。通过把子类的公共功能提炼和抽取，把公共部分放到模板里面去实现。

* 算法骨架不容易升级

    模板方法模式最基本的功能就是通过模板的制定，把算法骨架完全固定下来。事实上模板和子类是非常耦合的，如果要对模板中的算法骨架进行变更，可能就会要求所有相关的子类进行相应的变化。所以抽取算法骨架的时候要特别小心，尽量确保是不会变化的部分才放到模板中。