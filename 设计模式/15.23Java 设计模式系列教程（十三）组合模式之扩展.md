# Java 设计模式系列教程（十五）组合者模式

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[15.1 Java 设计模式系列教程（十二）组合模式之原理]()

[15.2 Java 设计模式系列教程（十二）组合模式之使用场景]()

[15.3 Java 设计模式系列教程（十二）组合模式之扩展]()

> 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象的使用具有一致性。[demo]()

## 1. 组合模式原理

### 15.1.1 组合模式结构

![15.1组合模式结构示意图](img/15.1.jpg)

* `Component`： 抽象的组件对象，为组合中的对象声明接口，让客户端可以通过这个接口来访问和管理整个对象结构，可以在里面为定义的功能提供缺省的实现。

* `Leaf`： 叶子节点对象，定义和实现叶子对象的行为，不再包含其它的子节点对象。

* `Composite`： 组合对象，通常会存储子组件，定义包含子组件的那些组件的行为，并实现在组件接口中定义的与子组件有关的操作。

* `Client`： 客户端，通过组件接口来操作组合结构里面的组件对象。

一种典型的Composite对象结构通常是如图15.2所示的树形结构，一个Composite对象可以包含多个叶子多象和其它的Composite对象，虽然15.2的图看起来好像有些对称，但是那只是为了让图看起来美观一点，并不是说Composite组合的对象结构就是这样对称的，这点要提前说明一下。

![15.2典型的Composite对象结构](img/15.2.jpg)

### 15.1.2 组合模式参考实现 [demo1]()

（1）先看看组件对象的定义，示例代码如下：

```java
/**
 * 抽象的组件对象，为组合中的对象声明接口，实现接口的缺省行为
 */
public abstract class Component {

    /**
     * 示意方法，子组件对象可能有的功能方法
     */
    public abstract void someOperation();

    /**
     * 向组合对象中加入组件对象
     * @param child 被加入组合对象中的组件对象
     */
    public void addChild(Component child) {
        // 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
        throw new UnsupportedOperationException("对象不支持这个功能");
    }

    /**
     * 从组合对象中移出某个组件对象
     * @param child 被移出的组件对象
     */
    public void removeChild(Component child) {
        // 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
        throw new UnsupportedOperationException("对象不支持这个功能");
    }

    /**
     * 返回某个索引对应的组件对象
     * @param index 需要获取的组件对象的索引，索引从0开始
     * @return 索引对应的组件对象
     */
    public Component getChildren(int index) {
        // 缺省的实现，抛出例外，因为叶子对象没有这个功能，或者子组件没有实现这个功能
        throw new UnsupportedOperationException("对象不支持这个功能");
    }
}
```

（2）接下来看看Composite对象的定义，示例代码如下：

```java
/**
 * 组合对象，通常需要存储子对象，定义有子部件的部件行为，
 * 并实现在Component里面定义的与子部件有关的操作
 */
public class Composite extends Component {
    /**
     * 用来存储组合对象中包含的子组件对象
     */
    private List<Component> childComponents = null;

    /**
     * 示意方法，通常在里面需要实现递归的调用
     */
    public void someOperation() {
        if (childComponents != null){
            for(Component c : childComponents){
                //递归的进行子组件相应方法的调用
                c.someOperation();
            }
        }
    }
    public void addChild(Component child) {
        //延迟初始化
        if (childComponents == null) {
            childComponents = new ArrayList<Component>();
        }
        childComponents.add(child);
    }

    public void removeChild(Component child) {
        if (childComponents != null) {
            childComponents.remove(child);
        }
    }

    public Component getChildren(int index) {
        if (childComponents != null){
            if(index>=0 && index<childComponents.size()){
                return childComponents.get(index);
            }
        }
        return null;
    }
}
```

（3）该来看叶子对象的定义了，相对而言比较简单，示例代码如下：

```java
/**
 * 叶子对象，叶子对象不再包含其它子对象
 */
public class Leaf extends Component {
    /**
     * 示意方法，叶子对象可能有自己的功能方法
     */
    public void someOperation() {
        // do something
    }

}
```

（4）对于Client，就是使用Component接口来操作组合对象结构，由于使用方式千差万别，这里仅仅提供一个示范性质的使用，顺便当作测试代码使用，示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        //定义多个Composite对象
        Component root = new Composite();
        Component c1 = new Composite();
        Component c2 = new Composite();
        //定义多个叶子对象
        Component leaf1 = new Leaf();
        Component leaf2 = new Leaf();
        Component leaf3 = new Leaf();

        //组和成为树形的对象结构
        root.addChild(c1);
        root.addChild(c2);
        root.addChild(leaf1);

        c1.addChild(leaf2);
        c2.addChild(leaf3);

        //操作Component对象
        Component o = root.getChildren(1);
        System.out.println(o);
    }
}
```

## 15.1.3 进一步认识组合者模式

#### （1）目标和观察者之间的关系