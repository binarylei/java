# 15.2 Java 设计模式系列教程（十五）组合模式之场景分析

[Java 设计模式系列教程目录](https://github.com/binarylei/java/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95.md)

[15.1 Java 设计模式系列教程（十五）组合模式之原理]()

[15.2 Java 设计模式系列教程（十五）组合模式之场景分析]()

[15.3 Java 设计模式系列教程（十五）组合模式之扩展]()

## 12.2.1 使用场景

考虑这样一个实际的应用：管理商品类别树。

在实现跟商品有关的应用系统的时候，一个很常见的功能就是商品类别树的管理，比如有如下所示的商品类别树：

```
+服装
    +男装
        -衬衣
        -夹克
    +女装
        -裙子
        -套装
```

仔细观察上面的商品类别树，有以下几个明显的特点：

1. 有一个根节点，比如服装，它没有父节点，它可以包含其它的节点
2. 树枝节点，有一类节点可以包含其它的节点，称之为树枝节点，比如男装、女装
3. 叶子节点，有一类节点没有子节点，称之为叶子节点，比如衬衣、夹克、裙子、套装
4. 现在需要管理商品类别树，假如就要求能实现输出如上商品类别树的结构的功能，应该如何实现呢？

## 15.2.2 不用模式的实现

### 代码实现

要管理商品类别树，就是要管理树的各个节点，现在树上的节点有三类，根节点、树枝节点和叶子节点，再进一步分析发现，根节点和树枝节点是类似的，都是可以包含其它节点的节点，把它们称为容器节点。

这样一来，商品类别树的节点就被分成了两种，一种是容器节点，另一种是叶子节点。容器节点可以包含其它的容器节点或者叶子节点。把它们分别实现成为对象，也就是容器对象和叶子对象，容器对象可以包含其它的容器对象或者叶子对象，换句话说，容器对象是一种组合对象。

然后在组合对象和叶子对象里面去实现要求的功能就可以了，看看代码实现。

（1）先看叶子对象的代码实现，示例代码如下：

```java
```

（2）再来看看组合对象的代码实现，组合对象里面可以包含其它的组合对象或者是叶子对象，由于类型不一样，需要分开记录。示例代码如下：

```java
```

（3）写个客户端来测试一下，看看是否能实现要求的功能，示例代码如下：

```java
```

运行一下，测试看看，是否能完成要求的功能。

### 问题出来了

上面的实现，虽然能实现要求的功能，但是有一个很明显的问题： **那就是必须区分组合对象和叶子对象，并进行有区别的对待** ，比如在Composite和Client里面，都需要去区别对待这两种对象。

区别对待组合对象和叶子对象，不仅让程序变得复杂，还对功能的扩展也带来不便。实际上，大多数情况下用户并不想要去区别它们，而是认为它们是一样的，这样他们操作起来最简单。

换句话说，对于这种具有整体与部分关系，并能组合成树形结构的对象结构，如何才能够以一个统一的方式来进行操作呢？

## 15.2.3 解决方案

### 应用组合模式的解决思路

理解了组合模式的定义、结构和示例代码过后，对组合模式应该有一定的掌握了，下面就来使用组合模式，来重写前面不用模式的示例，看看用组合模式来实现会是什么样子，跟不用模式有什么相同和不同之处。

为了整体理解和把握整个示例，先来看看示例的整体结构，如图15.3所示：

![图15.3  使用组合模式实现示例的结构示意图](img/15.3.jpg)

### 代码实现 [demo3]()

（1）首先就是要为组合对象和叶子对象添加一个抽象的父对象做为组件对象，在组件对象里面，定义一个输出组件本身名称的方法以实现要求的功能，示例代码如下：

```java
```

（2）先看叶子对象的实现，它变化比较少，只是让叶子对象继承了组件对象，其它的跟不用模式比较，没有什么变化，示例代码如下：

```java
```

（3）接下来看看组合对象的实现，这个对象变化就比较多，大致有如下的改变：

1. 新的Composite对象需要继承组件对象

2. 原来用来记录包含的其它组合对象的集合，和包含的其它叶子对象的集合，这两个集合被合并成为一个，就是统一的包含其它子组件对象的集合。使用组合模式来实现，不再需要区分到底是组合对象还是叶子对象了

3. 原来的addComposite和addLeaf的方法，可以不需要了，合并实现成组件对象中定义的方法addChild，当然需要现在的Composite来实现这个方法。使用组合模式来实现，不再需要区分到底是组合对象还是叶子对象了

4. 原来的printStruct方法的实现，完全要按照现在的方式来写，变化较大

具体的示例代码如下：

```java
```

（4）客户端也有变化，客户端不再需要区分组合对象和叶子对象了，统一都是使用组件对象，调用的方法也都要改变成组件对象定义的方法。示例代码如下：

```java
```

通过上面的示例，大家可以看出，通过使用组合模式，把一个“部分-整体”的层次结构表示成了对象树的结构，这样一来，客户端就无需再区分操作的是组合对象还是叶子对象了，对于客户端而言，操作的都是组件对象。