## 2.3 Netty核心技术之TCP拆包和粘包问题

### 2.3.1 拆包和粘包问题

1. 在 client 端向 server 端发送三次数据

```
//向服务器发送数据 buf
f.channel().writeAndFlush(Unpooled.copiedBuffer("ABC".getBytes()));
f.channel().writeAndFlush(Unpooled.copiedBuffer("DEF".getBytes()));
f.channel().writeAndFlush(Unpooled.copiedBuffer("GHI".getBytes()));
```

2. server 端可能将三次传输的数据当成一次请求，服务器收到的结果如下

```
ABCDEFGHI
```

### 2.3.2 解决方案

拆包和粘包问题的解决方案，根据业界主流协议，在有三种方案，前三种 Netty 已经实现：

1. 消息定长，例如每个报文的大小固定为200个字节，如果不够，空位补空格。

2. 在包尾部增加特殊字符进行分割，例如加回车等。

3. 将消息分为消息头和消息体，在消息头中包含表示消息总长度的字段，然后进行业务逻辑的处理。

### 2.3.3 定长方案 - FixedLengthFrameDecoder

1. 在 Server 中添加如下配制：[com.github.binarylei.t1]

```
childHandler(new ChannelInitializer<SocketChannel>() {
    @Override
    public void initChannel(SocketChannel sc) throws Exception {
        //定长拆包：5个字符，不足5位则忽略
        sc.pipeline().addLast(new FixedLengthFrameDecoder(5));
        //设置字符串形式的解码
        sc.pipeline().addLast(new StringDecoder());
        sc.pipeline().addLast(new ServerHandler());
    }
})
```

2. ServerHandler 中接收请求的数据：

```
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    System.out.println((String)msg);

    //写给客户端
    ChannelFuture f = ctx.writeAndFlush(Unpooled.copiedBuffer(((String)msg).getBytes()));
    //写完成后会自动关闭客户端
    //f.addListener(ChannelFutureListener.CLOSE);
}
```

3. Client 发送的数据：

```
//向服务器发送数据 buf
f.channel().writeAndFlush(Unpooled.copiedBuffer("aaaaabbbbb".getBytes()));
f.channel().writeAndFlush(Unpooled.copiedBuffer("cccccddd".getBytes()));
```

4. 结果如下，可以看出5个字符作为一个请求处理，不足5位的忽略：

```
aaaaa
bbbbb
ccccc
```

### 2.3.4 固定分隔符方案 - DelimiterBasedFrameDecoder

1. 在 Server 中添加如下配制：[com.github.binarylei.t2]

```
childHandler(new ChannelInitializer<SocketChannel>() {
    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ByteBuf buf = Unpooled.copiedBuffer("$_".getBytes());
        ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buf));
        //设置字符串形式的解码
        ch.pipeline().addLast(new StringDecoder());
        ch.pipeline().addLast(new ServerHandler());
    }
})
```

2. ServerHandler 中接收请求的数据：

```
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    System.out.println((String)msg);

    //写给客户端
    ChannelFuture f = ctx.writeAndFlush(Unpooled.copiedBuffer("netty$_".getBytes()));
    //写完成后会自动关闭客户端
    f.addListener(ChannelFutureListener.CLOSE);

}
```

结果如下，可以看出请求是分三次处理的：

```
ABC
DEF
GHI
```
### 2.3.4 自定义协议

Netty自定义协议请参考 [这篇文章](https://my.oschina.net/OutOfMemory/blog/290180)