## 2.4.1 ConcurrentLinkedQueue

> 适合高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能，通常 ConcurrentLinkedQueue 性能好于 LinkedBlockingQueue。它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则，且不允许 null 元素。

ConcurrentLinkedQueue 重要方法：

1. add()和offer()：添加元素(ConcurrentLinkedQueue 下两个方法无区别)。

2. poll()和peek()：取头元素节点，区别在于前者删除元素，后者不会。


## 2.4.2 LinkedBlockingQueue

### ArrayBlockingQueue

> 基于数组的阻塞队列实现，其内部维护了一个定长数组，以便缓存队列中的数据对象。没实现读写分离，也就意味着生产和消费不能完全并行，需要定义长度，可以指定先进先出或者先进后出，也叫有界队列。

### LinkedBlockingQueue

> 基于链表的阻塞队列实现，其内部维护了一个数据缓冲队列(链表构成)，以便缓存队列中的数据对象。实现了读写分离(读和写两个锁)，从而实现生产和消费的完全并行，进而能够高效的处理并发数据，是一个无界队列。

### SynchronousQueue

> 一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并消费。

### PriorityBlockingQueue

> 基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定，即传入队列的对象必须实现Comparable接口)实现。其内部控制线程同步的锁采用的是公平锁，也是一个无界队列。

### DelayQueue

> 带有延迟时间的队列，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取元素(传入的元素必须实现Delayed接口)，也是一个无界队列。应用场景比如缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等。

