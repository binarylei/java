## 2.3.1 ConcurrentMap容器

> ConcurrentHashMap 容器内部使用(Segment)来表示不同的部分，每个段其实就是一个小的 HashTable ，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。把一个整体分成了16个段(Segment)。也就是最高支持16个线程的并发修改操作。这也是在多线程场景时减小锁的粒度从而降低锁竞争一种方案。并且代码中大多共享变量使用 volatile 关键字声明，目的是第一时间获取修改的内容，性能非常好。

ConcurrentMap 接口下两个重要的实现:

* ConcurrentHashMap

* ConcurrentSkipListMap(排序)



## 2.3.2 Copy-On-Write容器

> CopyOnWrite 容器既写时复制的容器，用于读多写少的场景。往一个容器添加元素时，不直接往当前容器添加，而是先将当前容器 Copy ，复制一个新的容器，然后往新的容器添加元素，添加完成之后，再将原容器的引用指向新的容器，这样做的好处是可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器是一种读写分离的思想，读和写不同的容器。

**源代码：** 【java.util.concurrent.CopyOnWriteArrayList】

```java
//Copy-On-Write 容器是一种读写分离的思想
public class CopyOnWriteArrayList<E> {
    //Copy-On-Write 容器写操作时加锁，写操作结束后解锁
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();//加锁
        try {
            //1. 获取原容器
            Object[] elements = getArray();
            int len = elements.length;
            //2. 原容器 -> Copy -> 新容器
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            //3. 往新容器写入内容
            newElements[len] = e;
            //4. 指向新容器
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();//解锁
        }
    }

    //读操作没有加锁，可以支持并发操作
    @SuppressWarnings("unchecked")
    private E get(Object[] a, int index) {
        return (E) a[index];
    }

    public E get(int index) {
        return get(getArray(), index);
    }
}
```

Copy-On-Write 容器下两个重要的实现:

* CopyOnWriteArrayList

* CopyOnWriteArraySet

```java
import java.util.concurrent.CopyOnWriteArrayList;

public class Test {
    public static void main(String[] args) {
        //CopyOnWriteArrayList ====== List
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>();
        list.add("a");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
}
```