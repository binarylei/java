## 2.5.1 CountDownLatch

> 经常用于监听某些初始化操作，等初始化执行完毕后，通知主线程继续工作。

```java
import java.util.concurrent.CountDownLatch;

public class UseCountDownLatch extends Thread {

	public static void main(String[] args) {
		
		final CountDownLatch countDown = new CountDownLatch(2); //(1)
		
		Thread t1 = new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					System.out.println("进入线程t1" + "等待其他线程处理完成...");
					//阻塞当前线程
					countDown.await(); //(2)
					System.out.println("t1线程继续执行...");
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		},"t1");
		
		Thread t2 = new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					System.out.println("t2线程进行初始化操作...");
					Thread.sleep(3000);
					System.out.println("t2线程初始化完毕，通知t1线程继续...");
					countDown.countDown(); //(3)
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		});
		
		Thread t3 = new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					System.out.println("t3线程进行初始化操作...");
					Thread.sleep(4000);
					System.out.println("t3线程初始化完毕，通知t1线程继续...");
					countDown.countDown(); //(4)
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		});
		
		t1.start();
		t2.start();
		t3.start();
	}
}
```

1. 声明一个 CountDownLatch 对象，参数 2 表示被阻塞的线程需要被唤醒再次才能执行。

    ```java
    final CountDownLatch countDown = new CountDownLatch(2);
    ```

2. 阻塞当前线程-t1

    ```java
    countDown.await();
    ```
    
3. countDown() 调用两次后，线程t1继续执行

    ```java
    countDown.countDown();
    ```

4. 执行结果如下：

    ```
    进入线程t1等待其他线程处理完成...
    t2线程进行初始化操作...
    t3线程进行初始化操作...
    t2线程初始化完毕，通知t1线程继续...
    t3线程初始化完毕，通知t1线程继续...
    t1线程继续执行... //t1线程要等t2、t3线程执行完毕后才能继续执行
    ``` 

## 2.5.1 CyclicBarrier

> 假设有只有的一个场景：每个线程代表一个跑步运动员，当运动员都准备好后，才一起出发，只要有一个没有准备了，大家都等待。

```java
import java.io.IOException;  
import java.util.Random;  
import java.util.concurrent.BrokenBarrierException;  
import java.util.concurrent.CyclicBarrier;  
import java.util.concurrent.ExecutorService;  
import java.util.concurrent.Executors; 
public class UseCyclicBarrier {

	static class Runner implements Runnable {  
	    private CyclicBarrier barrier;  
	    private String name;  
	    
	    public Runner(CyclicBarrier barrier, String name) {  
	        this.barrier = barrier;  
	        this.name = name;  
	    }  
	    @Override  
	    public void run() {  
	        try {  
	            Thread.sleep(1000 * (new Random()).nextInt(5));  
	            System.out.println(name + " 准备OK.");  
	            barrier.await(); //(1) 
	        } catch (InterruptedException e) {  
	            e.printStackTrace();  
	        } catch (BrokenBarrierException e) {  
	            e.printStackTrace();  
	        }  
	        System.out.println(name + " Go!!");  
	    }  
	} 
	
    public static void main(String[] args) throws IOException, InterruptedException {  
        CyclicBarrier barrier = new CyclicBarrier(2);  // (2) 
        ExecutorService executor = Executors.newFixedThreadPool(2);  
        
        executor.submit(new Thread(new Runner(barrier, "Thread-1")));
        executor.submit(new Thread(new Runner(barrier, "Thread-2")));
  
        executor.shutdown();  
    }  
}
```

1. await() 阻塞当前的线程。

    ```java
    barrier.await();
    ```
    
2. 声明一个 CyclicBarrier 对象，参数 2 表示 barrier 必须有两个线程都准备好了才能执行。

    ```java
    CyclicBarrier barrier = new CyclicBarrier(2);
    ```
    
3. 执行结果如下：

    ```
    Thread-1 准备OK.
    Thread-2 准备OK.
    Thread-1 Go!!
    Thread-2 Go!!
    ```
    
4. 修改 `CyclicBarrier barrier = new CyclicBarrier(3)` 后这两个线程都会被阻塞， 执行结果如下：

    ```
    Thread-1 准备OK.
    Thread-2 准备OK.
    ```
    
## 2.5.3 Future

>  Future 模式适合在处理很耗时的业务逻辑时进行使用，可以有效的减少系统的响应时间，提高系统的吞吐量。

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;

public class UseFuture implements Callable<String>{ // (1)
	private String para;
	
	public UseFuture(String para){
		this.para = para;
	}
	
	/**
	 * 这里是真实的业务逻辑，其执行可能很慢
	 */
	@Override
	public String call() throws Exception {  // (2)
		//模拟执行耗时
		Thread.sleep(5000);
		String result = this.para + "处理完成";
		return result;
	}
	
	//主控制函数
	public static void main(String[] args) throws Exception {
		String queryStr = "query";
		//构造FutureTask，并且传入需要真正进行业务逻辑处理的类,该类一定是实现了Callable接口的类
		FutureTask<String> future = new FutureTask<String>(new UseFuture(queryStr));  // (3)
		FutureTask<String> future2 = new FutureTask<String>(new UseFuture(queryStr));

		//创建一个固定线程的线程池且线程数为1,
		ExecutorService executor = Executors.newFixedThreadPool(2);

		//提交任务FutureTask,则开启线程执行call()方法，submit和execute的区别：
        // 1. submit可以传入实现Callable接口的实例对象
        // 2. submit方法有返回值，当f1 == null 时，线程执行完毕
		Future f1 = executor.submit(future);		 // (4)
		Future f2 = executor.submit(future2);
		System.out.println("请求完毕");
		
		try {
			//这里可以做额外的数据操作，也就是主程序执行其他业务逻辑
			System.out.println("处理实际的业务逻辑...");
			Thread.sleep(1000);
		} catch (Exception e) {
			e.printStackTrace();
		}
		//调用获取数据方法,如果call()方法没有执行完成,则依然会进行等待
		System.out.println("数据：" + future.get()); // (5)
		System.out.println("数据：" + future2.get());
		
		executor.shutdown();
	}
}
```